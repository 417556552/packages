diff -ur nginx-1.7.1/auto/cc/gcc nginx-1.7.1-zimbra/auto/cc/gcc
--- nginx-1.7.1/auto/cc/gcc	2014-05-27 06:58:09.000000000 -0700
+++ nginx-1.7.1-zimbra/auto/cc/gcc	2014-07-23 12:24:07.000000000 -0700
@@ -50,7 +50,8 @@
 
 #NGX_GCC_OPT="-O2"
 #NGX_GCC_OPT="-Os"
-NGX_GCC_OPT="-O"
+#NGX_GCC_OPT="-O"
+NGX_GCC_OPT="-O0"
 
 #CFLAGS="$CFLAGS -fomit-frame-pointer"
 
diff -ur nginx-1.7.1/auto/lib/conf nginx-1.7.1-zimbra/auto/lib/conf
--- nginx-1.7.1/auto/lib/conf	2014-05-27 06:58:09.000000000 -0700
+++ nginx-1.7.1-zimbra/auto/lib/conf	2014-07-23 12:24:07.000000000 -0700
@@ -81,3 +81,7 @@
 if [ $NGX_LIBATOMIC != NO ]; then
     . auto/lib/libatomic/conf
 fi
+
+if [ $USE_SASL = YES ]; then
+    . auto/lib/sasl/conf
+fi
Only in nginx-1.7.1-zimbra/auto/lib: sasl
diff -ur nginx-1.7.1/auto/modules nginx-1.7.1-zimbra/auto/modules
--- nginx-1.7.1/auto/modules	2014-05-27 06:58:09.000000000 -0700
+++ nginx-1.7.1-zimbra/auto/modules	2014-07-23 12:24:07.000000000 -0700
@@ -386,6 +386,18 @@
     HTTP_SRCS="$HTTP_SRCS $HTTP_UPSTREAM_KEEPALIVE_SRCS"
 fi
 
+if [ $HTTP_UPSTREAM_ZMAUTH = YES ]; then
+    HTTP_MODULES="$HTTP_MODULES $HTTP_UPSTREAM_ZMAUTH_MODULE"
+    HTTP_SRCS="$HTTP_SRCS $HTTP_UPSTREAM_ZMAUTH_SRCS"
+    HTTP_DEPS="$HTTP_DEPS $HTTP_UPSTREAM_ZMAUTH_DEPS"
+fi
+
+if [ $HTTP_ZM_SSO = YES ]; then
+    HTTP_MODULES="$HTTP_MODULES $HTTP_ZM_SSO_MODULE"
+    HTTP_SRCS="$HTTP_SRCS $HTTP_ZM_SSO_SRCS"
+    HTTP_DEPS="$HTTP_DEPS $HTTP_ZM_SSO_DEPS"
+fi
+
 if [ $HTTP_STUB_STATUS = YES ]; then
     have=NGX_STAT_STUB . auto/have
     HTTP_MODULES="$HTTP_MODULES ngx_http_stub_status_module"
@@ -425,7 +437,8 @@
 
 
 modules="$CORE_MODULES $EVENT_MODULES"
-
+modules="$modules $MEMCACHE_MODULE"
+modules="$modules $ZM_LOOKUP_MODULE"
 
 if [ $USE_OPENSSL = YES ]; then
     modules="$modules $OPENSSL_MODULE"
@@ -454,6 +467,11 @@
 if [ $MAIL = YES ]; then
     modules="$modules $MAIL_MODULES"
 
+    if [ $MAIL_SASL = YES ]; then
+        USE_SASL=YES
+        have=NGX_MAIL_SASL . auto/have
+    fi
+
     if [ $MAIL_SSL = YES ]; then
         modules="$modules $MAIL_SSL_MODULE"
         MAIL_DEPS="$MAIL_DEPS $MAIL_SSL_DEPS"
@@ -481,9 +499,17 @@
     modules="$modules $MAIL_AUTH_HTTP_MODULE"
     MAIL_SRCS="$MAIL_SRCS $MAIL_AUTH_HTTP_SRCS"
 
+    modules="$modules $MAIL_ZMAUTH_MODULE"
+    MAIL_DEPS="$MAIL_DEPS $MAIL_ZMAUTH_DEPS"
+    MAIL_SRCS="$MAIL_SRCS $MAIL_ZMAUTH_SRCS"
+
     modules="$modules $MAIL_PROXY_MODULE"
     MAIL_SRCS="$MAIL_SRCS $MAIL_PROXY_SRCS"
 
+    modules="$modules $MAIL_THROTTLE_MODULE"
+    MAIL_DEPS="$MAIL_DEPS $MAIL_THROTTLE_DEPS"
+    MAIL_SRCS="$MAIL_SRCS $MAIL_THROTTLE_SRCS"
+
     NGX_ADDON_DEPS="$NGX_ADDON_DEPS \$(MAIL_DEPS)"
 fi
 
diff -ur nginx-1.7.1/auto/options nginx-1.7.1-zimbra/auto/options
--- nginx-1.7.1/auto/options	2014-05-27 06:58:09.000000000 -0700
+++ nginx-1.7.1-zimbra/auto/options	2014-07-23 12:24:07.000000000 -0700
@@ -102,11 +102,14 @@
 HTTP_UPSTREAM_IP_HASH=YES
 HTTP_UPSTREAM_LEAST_CONN=YES
 HTTP_UPSTREAM_KEEPALIVE=YES
+HTTP_UPSTREAM_ZMAUTH=NO
+HTTP_ZM_SSO=NO
 
 # STUB
 HTTP_STUB_STATUS=NO
 
 MAIL=NO
+MAIL_SASL=NO
 MAIL_SSL=NO
 MAIL_POP3=YES
 MAIL_IMAP=YES
@@ -128,6 +131,10 @@
 MD5_OPT=
 MD5_ASM=NO
 
+USE_SASL=NO
+SASL=NONE
+SASL_OPT=
+
 USE_SHA1=NO
 SHA1=NONE
 SHA1_OPT=
@@ -222,7 +229,9 @@
         --with-http_random_index_module) HTTP_RANDOM_INDEX=YES      ;;
         --with-http_secure_link_module)  HTTP_SECURE_LINK=YES       ;;
         --with-http_degradation_module)  HTTP_DEGRADATION=YES       ;;
-
+	--with-http_upstream_zmauth_module) HTTP_UPSTREAM_ZMAUTH=YES ;;
+        --with-http_zm_sso_module)       HTTP_ZM_SSO=YES            ;;
+        
         --without-http_charset_module)   HTTP_CHARSET=NO            ;;
         --without-http_gzip_module)      HTTP_GZIP=NO               ;;
         --without-http_ssi_module)       HTTP_SSI=NO                ;;
@@ -264,6 +273,7 @@
         --with-http_stub_status_module)  HTTP_STUB_STATUS=YES       ;;
 
         --with-mail)                     MAIL=YES                   ;;
+	    --with-mail-sasl)                MAIL_SASL=YES              ;;
         --with-mail_ssl_module)          MAIL_SSL=YES               ;;
         # STUB
         --with-imap)                     MAIL=YES                   ;;
@@ -297,6 +307,9 @@
         --with-md5-opt=*)                MD5_OPT="$value"           ;;
         --with-md5-asm)                  MD5_ASM=YES                ;;
 
+	    --with-sasl=*)                   SASL="$value"              ;;
+        --with-sasl-opt=*)               SASL_OPT="$value"          ;;
+
         --with-sha1=*)                   SHA1="$value"              ;;
         --with-sha1-opt=*)               SHA1_OPT="$value"          ;;
         --with-sha1-asm)                 SHA1_ASM=YES               ;;
@@ -373,6 +386,8 @@
   --with-http_secure_link_module     enable ngx_http_secure_link_module
   --with-http_degradation_module     enable ngx_http_degradation_module
   --with-http_stub_status_module     enable ngx_http_stub_status_module
+  --with-http_upstream_zmauth_module enable ngx_http_upstream_zmauth_module
+  --with-http_zm_sso_module          enable ngx_http_zm_sso_module
 
   --without-http_charset_module      disable ngx_http_charset_module
   --without-http_gzip_module         disable ngx_http_gzip_module
@@ -422,6 +437,7 @@
   --without-http-cache               disable HTTP cache
 
   --with-mail                        enable POP3/IMAP4/SMTP proxy module
+  --with-mail-sasl                   enable SASL support
   --with-mail_ssl_module             enable ngx_mail_ssl_module
   --without-mail_pop3_module         disable ngx_mail_pop3_module
   --without-mail_imap_module         disable ngx_mail_imap_module
@@ -450,6 +466,9 @@
   --with-md5-opt=OPTIONS             set additional build options for md5
   --with-md5-asm                     use md5 assembler sources
 
+  --with-sasl=DIR                    set path to sasl library sources
+  --with-sasl-opt=OPTIONS            set additional options for sasl building
+
   --with-sha1=DIR                    set path to sha1 library sources
   --with-sha1-opt=OPTIONS            set additional build options for sha1
   --with-sha1-asm                    use sha1 assembler sources
diff -ur nginx-1.7.1/auto/sources nginx-1.7.1-zimbra/auto/sources
--- nginx-1.7.1/auto/sources	2014-05-27 06:58:09.000000000 -0700
+++ nginx-1.7.1-zimbra/auto/sources	2014-07-23 12:24:07.000000000 -0700
@@ -36,6 +36,8 @@
            src/core/ngx_conf_file.h \
            src/core/ngx_resolver.h \
            src/core/ngx_open_file_cache.h \
+	   src/core/ngx_memcache.c \
+           src/core/ngx_zm_lookup.c \
            src/core/ngx_crypt.h \
            src/core/ngx_proxy_protocol.h \
            src/core/ngx_syslog.h"
@@ -69,6 +71,8 @@
            src/core/ngx_conf_file.c \
            src/core/ngx_resolver.c \
            src/core/ngx_open_file_cache.c \
+	   src/core/ngx_memcache.c \
+           src/core/ngx_zm_lookup.c \
            src/core/ngx_crypt.c \
            src/core/ngx_proxy_protocol.c \
            src/core/ngx_syslog.c"
@@ -140,6 +144,9 @@
 FILE_AIO_SRCS="src/os/unix/ngx_file_aio_read.c"
 LINUX_AIO_SRCS="src/os/unix/ngx_linux_aio_read.c"
 
+MEMCACHE_MODULE=ngx_memcache_module
+ZM_LOOKUP_MODULE=ngx_zm_lookup_module
+
 UNIX_INCS="$CORE_INCS $EVENT_INCS src/os/unix"
 
 UNIX_DEPS="$CORE_DEPS $EVENT_DEPS \
@@ -505,6 +512,13 @@
 HTTP_UPSTREAM_LEAST_CONN_SRCS=" \
     src/http/modules/ngx_http_upstream_least_conn_module.c"
 
+HTTP_UPSTREAM_ZMAUTH_MODULE=ngx_http_upstream_zmauth_module
+HTTP_UPSTREAM_ZMAUTH_SRCS=src/http/modules/ngx_http_upstream_zmauth_module.c
+HTTP_UPSTREAM_ZMAUTH_DEPS=src/http/modules/ngx_http_upstream_zmauth_module.h
+
+HTTP_ZM_SSO_MODULE=ngx_http_zm_sso_module
+HTTP_ZM_SSO_SRCS=src/http/modules/ngx_http_zm_sso_module.c
+HTTP_ZM_SSO_DEPS=src/http/modules/ngx_http_zm_sso_module.h
 
 HTTP_UPSTREAM_KEEPALIVE_MODULE=ngx_http_upstream_keepalive_module
 HTTP_UPSTREAM_KEEPALIVE_SRCS=" \
@@ -544,9 +558,17 @@
 MAIL_AUTH_HTTP_MODULE="ngx_mail_auth_http_module"
 MAIL_AUTH_HTTP_SRCS="src/mail/ngx_mail_auth_http_module.c"
 
+MAIL_ZMAUTH_MODULE="ngx_mail_zmauth_module"
+MAIL_ZMAUTH_DEPS="src/mail/ngx_mail_zmauth_module.h"
+MAIL_ZMAUTH_SRCS="src/mail/ngx_mail_zmauth_module.c"
+
 MAIL_PROXY_MODULE="ngx_mail_proxy_module"
 MAIL_PROXY_SRCS="src/mail/ngx_mail_proxy_module.c"
 
+MAIL_THROTTLE_MODULE="ngx_mail_throttle_module"
+MAIL_THROTTLE_DEPS="src/mail/ngx_mail_throttle_module.h"
+MAIL_THROTTLE_SRCS="src/mail/ngx_mail_throttle_module.c"
+
 NGX_GOOGLE_PERFTOOLS_MODULE=ngx_google_perftools_module
 NGX_GOOGLE_PERFTOOLS_SRCS=src/misc/ngx_google_perftools_module.c
 
Only in nginx-1.7.1-zimbra/html: zmerror_upstream_502.html
Only in nginx-1.7.1-zimbra/html: zmerror_upstream_504.html
diff -ur nginx-1.7.1/src/core/ngx_cycle.c nginx-1.7.1-zimbra/src/core/ngx_cycle.c
--- nginx-1.7.1/src/core/ngx_cycle.c	2014-05-27 06:58:09.000000000 -0700
+++ nginx-1.7.1-zimbra/src/core/ngx_cycle.c	2014-08-11 16:48:56.000000000 -0700
@@ -375,6 +375,17 @@
             goto failed;
         }
 
+	//bug 55962, change the owner of log file when current effective
+        //user is root
+        if (geteuid() == 0 && ccf->user != (ngx_uid_t) NGX_CONF_UNSET_UINT) {
+            int rc = fchown(file[i].fd, ccf->user, ccf->group);
+            if(rc != 0) {
+                ngx_log_error(NGX_LOG_WARN, log, ngx_errno,
+                        "Cannot set the owner of log file \"%V\" "
+                        "to user \"%s\"", &file[i].name, &ccf->username);
+            }
+        }
+
 #if !(NGX_WIN32)
         if (fcntl(file[i].fd, F_SETFD, FD_CLOEXEC) == -1) {
             ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,
diff -ur nginx-1.7.1/src/core/ngx_log.c nginx-1.7.1-zimbra/src/core/ngx_log.c
--- nginx-1.7.1/src/core/ngx_log.c	2014-05-27 06:58:09.000000000 -0700
+++ nginx-1.7.1-zimbra/src/core/ngx_log.c	2014-07-23 12:24:07.000000000 -0700
@@ -69,7 +69,7 @@
 
 static const char *debug_levels[] = {
     "debug_core", "debug_alloc", "debug_mutex", "debug_event",
-    "debug_http", "debug_mail", "debug_mysql"
+    "debug_http", "debug_mail", "debug_mysql","debug_zimbra"
 };
 
 
diff -ur nginx-1.7.1/src/core/ngx_log.h nginx-1.7.1-zimbra/src/core/ngx_log.h
--- nginx-1.7.1/src/core/ngx_log.h	2014-05-27 06:58:09.000000000 -0700
+++ nginx-1.7.1-zimbra/src/core/ngx_log.h	2014-07-23 12:24:07.000000000 -0700
@@ -30,6 +30,7 @@
 #define NGX_LOG_DEBUG_HTTP        0x100
 #define NGX_LOG_DEBUG_MAIL        0x200
 #define NGX_LOG_DEBUG_MYSQL       0x400
+#define NGX_LOG_DEBUG_ZIMBRA      0x800
 
 /*
  * do not forget to update debug_levels[] in src/core/ngx_log.c
@@ -37,7 +38,7 @@
  */
 
 #define NGX_LOG_DEBUG_FIRST       NGX_LOG_DEBUG_CORE
-#define NGX_LOG_DEBUG_LAST        NGX_LOG_DEBUG_MYSQL
+#define NGX_LOG_DEBUG_LAST        NGX_LOG_DEBUG_ZIMBRA
 #define NGX_LOG_DEBUG_CONNECTION  0x80000000
 #define NGX_LOG_DEBUG_ALL         0x7ffffff0
 
Only in nginx-1.7.1-zimbra/src/core: ngx_memcache.c
Only in nginx-1.7.1-zimbra/src/core: ngx_memcache.h
diff -ur nginx-1.7.1/src/core/ngx_string.c nginx-1.7.1-zimbra/src/core/ngx_string.c
--- nginx-1.7.1/src/core/ngx_string.c	2014-05-27 06:58:09.000000000 -0700
+++ nginx-1.7.1-zimbra/src/core/ngx_string.c	2014-07-23 12:24:08.000000000 -0700
@@ -68,6 +68,24 @@
     return dst;
 }
 
+ngx_str_t *
+ngx_pstrcpy(ngx_pool_t *pool, ngx_str_t *src) {
+    ngx_str_t * dst;
+
+    dst = ngx_pnalloc(pool, sizeof(ngx_str_t));
+    if (dst == NULL) {
+        return NULL;
+    }
+
+    dst->data = ngx_pnalloc(pool, src->len);
+    if (dst->data == NULL) {
+        return NULL;
+    }
+
+    ngx_memcpy(dst->data, src->data, src->len);
+    dst->len = src->len;
+    return dst;
+}
 
 /*
  * supported formats:
diff -ur nginx-1.7.1/src/core/ngx_string.h nginx-1.7.1-zimbra/src/core/ngx_string.h
--- nginx-1.7.1/src/core/ngx_string.h	2014-05-27 06:58:09.000000000 -0700
+++ nginx-1.7.1-zimbra/src/core/ngx_string.h	2014-07-23 12:24:08.000000000 -0700
@@ -146,6 +146,7 @@
 
 u_char *ngx_cpystrn(u_char *dst, u_char *src, size_t n);
 u_char *ngx_pstrdup(ngx_pool_t *pool, ngx_str_t *src);
+ngx_str_t *ngx_pstrcpy(ngx_pool_t *pool, ngx_str_t *src);
 u_char * ngx_cdecl ngx_sprintf(u_char *buf, const char *fmt, ...);
 u_char * ngx_cdecl ngx_snprintf(u_char *buf, size_t max, const char *fmt, ...);
 u_char * ngx_cdecl ngx_slprintf(u_char *buf, u_char *last, const char *fmt,
Only in nginx-1.7.1-zimbra/src/core: ngx_zm_lookup.c
Only in nginx-1.7.1-zimbra/src/core: ngx_zm_lookup.h
Only in nginx-1.7.1-zimbra/src/http/modules: ngx_http_upstream_zmauth_module.c
Only in nginx-1.7.1-zimbra/src/http/modules: ngx_http_upstream_zmauth_module.h
Only in nginx-1.7.1-zimbra/src/http/modules: ngx_http_zm_sso_module.c
Only in nginx-1.7.1-zimbra/src/http/modules: ngx_http_zm_sso_module.h
diff -ur nginx-1.7.1/src/http/ngx_http_core_module.c nginx-1.7.1-zimbra/src/http/ngx_http_core_module.c
--- nginx-1.7.1/src/http/ngx_http_core_module.c	2014-05-27 06:58:10.000000000 -0700
+++ nginx-1.7.1-zimbra/src/http/ngx_http_core_module.c	2014-07-23 12:24:09.000000000 -0700
@@ -789,6 +789,13 @@
 
 #endif
 
+    { ngx_string("exact_version_check"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_FLAG,
+      ngx_conf_set_flag_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_core_loc_conf_t, exact_version_check),
+      NULL },
+
       ngx_null_command
 };
 
@@ -3633,6 +3640,7 @@
     clcf->open_file_cache_min_uses = NGX_CONF_UNSET_UINT;
     clcf->open_file_cache_errors = NGX_CONF_UNSET;
     clcf->open_file_cache_events = NGX_CONF_UNSET;
+    clcf->exact_version_check = NGX_CONF_UNSET;
 
 #if (NGX_HTTP_GZIP)
     clcf->gzip_vary = NGX_CONF_UNSET;
@@ -3901,6 +3909,9 @@
 
     ngx_conf_merge_sec_value(conf->open_file_cache_events,
                               prev->open_file_cache_events, 0);
+
+    ngx_conf_merge_value(conf->exact_version_check,
+        					  prev->exact_version_check, 1);
 #if (NGX_HTTP_GZIP)
 
     ngx_conf_merge_value(conf->gzip_vary, prev->gzip_vary, 0);
diff -ur nginx-1.7.1/src/http/ngx_http_core_module.h nginx-1.7.1-zimbra/src/http/ngx_http_core_module.h
--- nginx-1.7.1/src/http/ngx_http_core_module.h	2014-05-27 06:58:10.000000000 -0700
+++ nginx-1.7.1-zimbra/src/http/ngx_http_core_module.h	2014-07-23 12:24:09.000000000 -0700
@@ -412,6 +412,7 @@
     ngx_flag_t    server_tokens;           /* server_tokens */
     ngx_flag_t    chunked_transfer_encoding; /* chunked_transfer_encoding */
     ngx_flag_t    etag;                    /* etag */
+    ngx_flag_t    exact_version_check;     /* exact_version_check added by zimbra */
 
 #if (NGX_HTTP_GZIP)
     ngx_flag_t    gzip_vary;               /* gzip_vary */
diff -ur nginx-1.7.1/src/http/ngx_http_request.c nginx-1.7.1-zimbra/src/http/ngx_http_request.c
--- nginx-1.7.1/src/http/ngx_http_request.c	2014-05-27 06:58:10.000000000 -0700
+++ nginx-1.7.1-zimbra/src/http/ngx_http_request.c	2014-07-23 12:24:10.000000000 -0700
@@ -1828,6 +1828,13 @@
 
     c = r->connection;
 
+    if (r->plain_http) {
+    	ngx_log_error(NGX_LOG_INFO, c->log, 0,
+    			"client sent plain HTTP request to HTTPS port");
+        ngx_http_finalize_request(r, NGX_HTTP_TO_HTTPS);
+        return;
+    }
+
 #if (NGX_HTTP_SSL)
 
     if (r->http_connection->ssl) {
diff -ur nginx-1.7.1/src/http/ngx_http_request.h nginx-1.7.1-zimbra/src/http/ngx_http_request.h
--- nginx-1.7.1/src/http/ngx_http_request.h	2014-05-27 06:58:10.000000000 -0700
+++ nginx-1.7.1-zimbra/src/http/ngx_http_request.h	2014-07-23 12:24:10.000000000 -0700
@@ -504,6 +504,7 @@
 #endif
 
     unsigned                          pipeline:1;
+    unsigned                          plain_http:1;
     unsigned                          chunked:1;
     unsigned                          header_only:1;
     unsigned                          keepalive:1;
diff -ur nginx-1.7.1/src/http/ngx_http_upstream.c nginx-1.7.1-zimbra/src/http/ngx_http_upstream.c
--- nginx-1.7.1/src/http/ngx_http_upstream.c	2014-05-27 06:58:10.000000000 -0700
+++ nginx-1.7.1-zimbra/src/http/ngx_http_upstream.c	2014-07-23 12:24:10.000000000 -0700
@@ -8,7 +8,7 @@
 #include <ngx_config.h>
 #include <ngx_core.h>
 #include <ngx_http.h>
-
+#include <ngx_zm_lookup.h>
 
 #if (NGX_HTTP_CACHE)
 static ngx_int_t ngx_http_upstream_cache(ngx_http_request_t *r,
@@ -482,6 +482,7 @@
 {
     ngx_str_t                      *host;
     ngx_uint_t                      i;
+    ngx_int_t			    rc;
     ngx_resolver_ctx_t             *ctx, temp;
     ngx_http_cleanup_t             *cln;
     ngx_http_upstream_t            *u;
@@ -681,7 +682,10 @@
     u->ssl_name = uscf->host;
 #endif
 
-    if (uscf->peer.init(r, uscf) != NGX_OK) {
+    rc = uscf->peer.init(r, uscf);
+    if (rc != NGX_OK) {
+        if (rc == NGX_AGAIN) return; /* added by zimbra to support async peer init */
+
         ngx_http_upstream_finalize_request(r, u,
                                            NGX_HTTP_INTERNAL_SERVER_ERROR);
         return;
@@ -1365,6 +1369,7 @@
 
     c->sendfile = 0;
     u->output.sendfile = 0;
+    ngx_http_upstream_rr_peer_data_t *rrp = (ngx_http_upstream_rr_peer_data_t *)(u->peer.data);
 
     if (u->conf->ssl_server_name || u->conf->ssl_verify) {
         if (ngx_http_upstream_ssl_name(r, u, c) != NGX_OK) {
@@ -1374,7 +1379,7 @@
         }
     }
 
-    if (u->conf->ssl_session_reuse) {
+    if (u->conf->ssl_session_reuse && rrp->current != NGX_INVALID_ARRAY_INDEX) {
         if (u->peer.set_session(&u->peer, u->peer.data) != NGX_OK) {
             ngx_http_upstream_finalize_request(r, u,
                                                NGX_HTTP_INTERNAL_SERVER_ERROR);
@@ -1425,7 +1430,9 @@
             }
         }
 
-        if (u->conf->ssl_session_reuse) {
+	ngx_http_upstream_rr_peer_data_t *rrp = (ngx_http_upstream_rr_peer_data_t *)(u->peer.data);
+
+        if (u->conf->ssl_session_reuse && rrp->current != NGX_INVALID_ARRAY_INDEX) {
             u->peer.save_session(&u->peer, u->peer.data);
         }
 
@@ -3402,6 +3409,7 @@
     ngx_uint_t ft_type)
 {
     ngx_uint_t  status, state;
+    ngx_zm_lookup_conf_t  *zlcf;
 
     ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                    "http next upstream, %xi", ft_type);
@@ -3471,8 +3479,13 @@
     if (status) {
         u->state->status = status;
 
-        if (u->peer.tries == 0 || !(u->conf->next_upstream & ft_type)) {
+        zlcf = (ngx_zm_lookup_conf_t *)
+                ngx_get_conf (ngx_cycle->conf_ctx, ngx_zm_lookup_module);
 
+        if (u->peer.tries == 0 || !(u->conf->next_upstream & ft_type) ||
+                (r->method == NGX_HTTP_POST && !((r->uri.len == 1 &&
+                        r->uri.data[r->uri.len - 1] == '/') ||
+                        (ngx_strcasecmp(r->uri.data, zlcf->url.data) == 0)))) {
 #if (NGX_HTTP_CACHE)
 
             if (u->cache_status == NGX_HTTP_CACHE_EXPIRED
@@ -4792,7 +4805,8 @@
                                          |NGX_HTTP_UPSTREAM_MAX_FAILS
                                          |NGX_HTTP_UPSTREAM_FAIL_TIMEOUT
                                          |NGX_HTTP_UPSTREAM_DOWN
-                                         |NGX_HTTP_UPSTREAM_BACKUP);
+                                         |NGX_HTTP_UPSTREAM_BACKUP
+                                         |NGX_HTTP_UPSTREAM_VERSION);
     if (uscf == NULL) {
         return NGX_CONF_ERROR;
     }
@@ -4872,6 +4886,9 @@
         return NGX_CONF_ERROR;
     }
 
+    /* add by zimbra to support async upstream peer choose */
+    uscf->connect = ngx_http_upstream_connect;
+
     return rv;
 }
 
@@ -4882,7 +4899,7 @@
     ngx_http_upstream_srv_conf_t  *uscf = conf;
 
     time_t                       fail_timeout;
-    ngx_str_t                   *value, s;
+    ngx_str_t                   *value, s, version;
     ngx_url_t                    u;
     ngx_int_t                    weight, max_fails;
     ngx_uint_t                   i;
@@ -4922,6 +4939,8 @@
     weight = 1;
     max_fails = 1;
     fail_timeout = 10;
+    version.len = 0;
+    version.data = NULL;
 
     for (i = 2; i < cf->args->nelts; i++) {
 
@@ -4995,6 +5014,20 @@
             continue;
         }
 
+        if (ngx_strncmp(value[i].data, "version=", 8) == 0) {
+
+        	if (!(uscf->flags & NGX_HTTP_UPSTREAM_VERSION)) {
+              	goto invalid;
+            }
+
+        	s.len = value[i].len - 8;
+            s.data = &value[i].data[8];
+
+            version = s;
+
+            continue;
+        }
+
         goto invalid;
     }
 
@@ -5003,6 +5036,7 @@
     us->weight = weight;
     us->max_fails = max_fails;
     us->fail_timeout = fail_timeout;
+    us->version = version;
 
     return NGX_CONF_OK;
 
diff -ur nginx-1.7.1/src/http/ngx_http_upstream.h nginx-1.7.1-zimbra/src/http/ngx_http_upstream.h
--- nginx-1.7.1/src/http/ngx_http_upstream.h	2014-05-27 06:58:10.000000000 -0700
+++ nginx-1.7.1-zimbra/src/http/ngx_http_upstream.h	2014-07-23 12:24:10.000000000 -0700
@@ -92,6 +92,7 @@
     ngx_uint_t                       weight;
     ngx_uint_t                       max_fails;
     time_t                           fail_timeout;
+    ngx_str_t                        version;
 
     unsigned                         down:1;
     unsigned                         backup:1;
@@ -104,7 +105,7 @@
 #define NGX_HTTP_UPSTREAM_FAIL_TIMEOUT  0x0008
 #define NGX_HTTP_UPSTREAM_DOWN          0x0010
 #define NGX_HTTP_UPSTREAM_BACKUP        0x0020
-
+#define NGX_HTTP_UPSTREAM_VERSION       0x0040
 
 struct ngx_http_upstream_srv_conf_s {
     ngx_http_upstream_peer_t         peer;
@@ -119,6 +120,9 @@
     in_port_t                        port;
     in_port_t                        default_port;
     ngx_uint_t                       no_port;  /* unsigned no_port:1 */
+
+    // added by zimbra to support async upstream peer init
+    void (* connect)(ngx_http_request_t *r, ngx_http_upstream_t *u);
 };
 
 
diff -ur nginx-1.7.1/src/http/ngx_http_upstream_round_robin.c nginx-1.7.1-zimbra/src/http/ngx_http_upstream_round_robin.c
--- nginx-1.7.1/src/http/ngx_http_upstream_round_robin.c	2014-05-27 06:58:10.000000000 -0700
+++ nginx-1.7.1-zimbra/src/http/ngx_http_upstream_round_robin.c	2014-07-23 12:24:10.000000000 -0700
@@ -11,7 +11,7 @@
 
 
 static ngx_http_upstream_rr_peer_t *ngx_http_upstream_get_peer(
-    ngx_http_upstream_rr_peer_data_t *rrp);
+    ngx_http_upstream_rr_peer_data_t *rrp, ngx_log_t* log);
 
 #if (NGX_HTTP_SSL)
 
@@ -85,6 +85,7 @@
                 peers->peer[n].max_fails = server[i].max_fails;
                 peers->peer[n].fail_timeout = server[i].fail_timeout;
                 peers->peer[n].down = server[i].down;
+                peers->peer[n].version = server[i].version;
                 n++;
             }
         }
@@ -139,6 +140,7 @@
                 backup->peer[n].max_fails = server[i].max_fails;
                 backup->peer[n].fail_timeout = server[i].fail_timeout;
                 backup->peer[n].down = server[i].down;
+                backup->peer[n].version = server[i].version;
                 n++;
             }
         }
@@ -196,6 +198,8 @@
         peers->peer[i].current_weight = 0;
         peers->peer[i].max_fails = 1;
         peers->peer[i].fail_timeout = 10;
+        peers->peer[n].version.len = 0;
+        peers->peer[n].version.data = NULL;
     }
 
     us->peer.data = peers;
@@ -302,6 +306,8 @@
         peers->peer[0].current_weight = 0;
         peers->peer[0].max_fails = 1;
         peers->peer[0].fail_timeout = 10;
+        peers->peer[0].version.len = 0;
+        peers->peer[0].version.data = NULL;
 
     } else {
 
@@ -342,6 +348,8 @@
             peers->peer[i].current_weight = 0;
             peers->peer[i].max_fails = 1;
             peers->peer[i].fail_timeout = 10;
+            peers->peer[i].version.len = 0;
+            peers->peer[i].version.data = NULL;
         }
     }
 
@@ -403,15 +411,15 @@
 
         /* there are several peers */
 
-        peer = ngx_http_upstream_get_peer(rrp);
+        peer = ngx_http_upstream_get_peer(rrp, pc->log);
 
         if (peer == NULL) {
             goto failed;
         }
 
-        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, pc->log, 0,
-                       "get rr peer, current: %ui %i",
-                       rrp->current, peer->current_weight);
+        ngx_log_debug3(NGX_LOG_DEBUG_HTTP, pc->log, 0,
+                       "get rr peer, current: %ui %i version:%s",
+                       rrp->current, peer->current_weight, peer->version);
     }
 
     pc->sockaddr = peer->sockaddr;
@@ -470,7 +478,7 @@
 
 
 static ngx_http_upstream_rr_peer_t *
-ngx_http_upstream_get_peer(ngx_http_upstream_rr_peer_data_t *rrp)
+ngx_http_upstream_get_peer(ngx_http_upstream_rr_peer_data_t *rrp, ngx_log_t* log)
 {
     time_t                        now;
     uintptr_t                     m;
@@ -505,6 +513,10 @@
             continue;
         }
 
+        if (ngx_http_upstream_peer_version_allowed(peer, rrp, log) == 0) {
+        	continue;
+        }
+
         peer->current_weight += peer->effective_weight;
         total += peer->effective_weight;
 
@@ -600,6 +612,69 @@
     /* ngx_unlock_mutex(rrp->peers->mutex); */
 }
 
+/* check if this upstream peer is allowed (same exact version/same major-minor version based on exact_version_check flag)
+ * return 1 if allowed, 0 if not */
+ngx_flag_t
+ngx_http_upstream_peer_version_allowed(ngx_http_upstream_rr_peer_t *peer, void* data,
+									   ngx_log_t* log) {
+	ngx_http_upstream_rr_peer_data_t* rrp = data;
+	ngx_uint_t peer_version[2], auth_token_version[2];
+	ngx_flag_t f = 1;
+	ngx_uint_t j = 0;
+	char *ptr = NULL;
+
+	/* Version check enforcement when the auth_token contains a version */
+	if (rrp->version.len && peer->version.len == 0) {
+		// Peer does not have version set in nginx conf
+		ngx_log_debug0(NGX_LOG_DEBUG_HTTP, log, 0,
+						"auth_token has a version but the peer doesn't, skipping peer");
+		return 0;
+	} else if (rrp->version.len && peer->version.len) {
+		// Peer has version set in nginx conf
+		if (rrp->exact_version_check) {
+			// if the server version check is non-permissive (needs to be an exact match)
+			ngx_log_debug0(NGX_LOG_DEBUG_HTTP, log, 0,
+					"exact_version_check is on");
+	        if (rrp->version.len != peer->version.len || ngx_memcmp(rrp->version.data, peer->version.data, rrp->version.len)) {
+	        	ngx_log_debug1(NGX_LOG_DEBUG_HTTP, log, 0,
+	        			"skipping peer at a different version %V", &peer->version);
+	        	f = 0;
+	        }
+	    } else {
+	    	// if the server version check is permissive (eg. all 8.5.x will be treated same by nginx)
+	    	ngx_log_debug0(NGX_LOG_DEBUG_HTTP, log, 0,
+	    			"exact_version_check is off");
+
+	        ptr = strtok ((char *)rrp->version.data,".");
+	        while (ptr != NULL && (j < 2)) {
+	        	auth_token_version[j] = atoi(ptr);
+	        	ngx_log_debug2(NGX_LOG_DEBUG_HTTP, log, 0,
+	        			"auth_token_version[%d] = %d", j, auth_token_version[j]);
+	        	ptr = strtok (NULL, ".");
+	        	j++;
+	        }
+	        j = 0;
+	        ptr = strtok ((char *)peer->version.data,".");
+	        while (ptr != NULL && (j < 2)) {
+	        	peer_version[j] = atoi(ptr);
+	        	ngx_log_debug2(NGX_LOG_DEBUG_HTTP, log, 0,
+	        			"peer_version[%d] = %d", j, peer_version[j]);
+	        	ptr = strtok (NULL, ".");
+	        	j++;
+	        }
+	        // Compare if the major and minor revisions are same
+	        for (j = 0; j < 2; j++) {
+	        	if (auth_token_version[j] != peer_version[j]) {
+	        		ngx_log_debug1(NGX_LOG_DEBUG_HTTP, log, 0,
+	        				"skipping peer at a different major/minor version %V", &peer->version);
+	        		f = 0;
+	        	}
+	        }
+	    }
+	}
+
+	return f;
+}
 
 #if (NGX_HTTP_SSL)
 
diff -ur nginx-1.7.1/src/http/ngx_http_upstream_round_robin.h nginx-1.7.1-zimbra/src/http/ngx_http_upstream_round_robin.h
--- nginx-1.7.1/src/http/ngx_http_upstream_round_robin.h	2014-05-27 06:58:10.000000000 -0700
+++ nginx-1.7.1-zimbra/src/http/ngx_http_upstream_round_robin.h	2014-07-23 12:24:10.000000000 -0700
@@ -32,6 +32,7 @@
 
     ngx_uint_t                      down;          /* unsigned  down:1; */
 
+    ngx_str_t	                    version;       /* upstream server version */
 #if (NGX_HTTP_SSL)
     ngx_ssl_session_t              *ssl_session;   /* local to a process */
 #endif
@@ -63,6 +64,8 @@
     ngx_uint_t                      current;
     uintptr_t                      *tried;
     uintptr_t                       data;
+    ngx_str_t                       version;
+    ngx_flag_t                      exact_version_check;
 } ngx_http_upstream_rr_peer_data_t;
 
 
@@ -76,6 +79,8 @@
     void *data);
 void ngx_http_upstream_free_round_robin_peer(ngx_peer_connection_t *pc,
     void *data, ngx_uint_t state);
+ngx_flag_t ngx_http_upstream_peer_version_allowed(ngx_http_upstream_rr_peer_t *peer,
+	void* data, ngx_log_t* log);
 
 #if (NGX_HTTP_SSL)
 ngx_int_t
diff -ur nginx-1.7.1/src/mail/ngx_mail.h nginx-1.7.1-zimbra/src/mail/ngx_mail.h
--- nginx-1.7.1/src/mail/ngx_mail.h	2014-05-27 06:58:10.000000000 -0700
+++ nginx-1.7.1-zimbra/src/mail/ngx_mail.h	2014-07-23 12:24:10.000000000 -0700
@@ -18,7 +18,7 @@
 #include <ngx_mail_ssl_module.h>
 #endif
 
-
+#include <sasl/sasl.h>
 
 typedef struct {
     void                  **main_conf;
@@ -135,6 +135,16 @@
 
     ngx_str_t               server_name;
 
+    ngx_str_t               master_auth_username;
+    ngx_str_t               master_auth_password;
+
+    ngx_str_t               sasl_app_name;
+    ngx_str_t               sasl_service_name;
+    ngx_flag_t              sasl_host_from_ip;
+
+    ngx_msec_t              auth_wait_intvl;
+
+    ngx_str_t               default_realm;
     u_char                 *file_name;
     ngx_int_t               line;
 
@@ -147,12 +157,15 @@
 
 typedef enum {
     ngx_pop3_start = 0,
+    ngx_pop3_xoip,
     ngx_pop3_user,
     ngx_pop3_passwd,
     ngx_pop3_auth_login_username,
     ngx_pop3_auth_login_password,
     ngx_pop3_auth_plain,
-    ngx_pop3_auth_cram_md5
+    ngx_pop3_auth_plain_response,
+    ngx_pop3_auth_cram_md5,
+    ngx_pop3_auth_gssapi
 } ngx_pop3_state_e;
 
 
@@ -161,7 +174,10 @@
     ngx_imap_auth_login_username,
     ngx_imap_auth_login_password,
     ngx_imap_auth_plain,
+    ngx_imap_auth_plain_ir,
+    ngx_imap_auth_gssapi,
     ngx_imap_auth_cram_md5,
+    ngx_imap_id,
     ngx_imap_login,
     ngx_imap_user,
     ngx_imap_passwd
@@ -173,8 +189,10 @@
     ngx_smtp_auth_login_username,
     ngx_smtp_auth_login_password,
     ngx_smtp_auth_plain,
+    ngx_smtp_auth_gssapi,
     ngx_smtp_auth_cram_md5,
     ngx_smtp_helo,
+    ngx_smtp_noxclient,
     ngx_smtp_helo_xclient,
     ngx_smtp_helo_from,
     ngx_smtp_xclient,
@@ -184,12 +202,27 @@
     ngx_smtp_to
 } ngx_smtp_state_e;
 
+/* sasl auth mechanisms */
+typedef enum {
+    ngx_auth_unknown = 0,
+    ngx_auth_plain,
+    ngx_auth_gssapi,
+} ngx_auth_e;
 
 typedef struct {
     ngx_peer_connection_t   upstream;
     ngx_buf_t              *buffer;
 } ngx_mail_proxy_ctx_t;
 
+typedef void (*ngx_mail_cleanup_pt)(void *data);
+
+typedef struct ngx_mail_cleanup_s  ngx_mail_cleanup_t;
+
+struct ngx_mail_cleanup_s {
+    ngx_mail_cleanup_pt               handler;
+    void                             *data;
+    ngx_mail_cleanup_t               *next;
+};
 
 typedef struct {
     uint32_t                signature;         /* "MAIL" */
@@ -209,6 +242,8 @@
 
     ngx_uint_t              mail_state;
 
+    ngx_str_t               greetings[3];
+
     unsigned                protocol:3;
     unsigned                blocked:1;
     unsigned                quit:1;
@@ -217,11 +252,25 @@
     unsigned                no_sync_literal:1;
     unsigned                starttls:1;
     unsigned                esmtp:1;
-    unsigned                auth_method:3;
+    unsigned                auth_method:4;
     unsigned                auth_wait:1;
 
-    ngx_str_t               login;
+    unsigned                sendquitmsg:1;
+    unsigned                vlogin:2; /* vlogin = 0 fqdn is not looked up;
+                                         vlogin = 1 fqdn has been looked up but not found;
+                                         vlogin = 2 fqdn has been looked up and assigned to "login"
+                                       */
+
+    ngx_str_t               login;  /* keep the original user input login */
+
+    ngx_str_t               qlogin; /* initially equal to 'login', then hold account name
+                                       after successful alias cache fetch or route lookup
+                                       this value is finally used to login the upstream
+                                       mail server*/
+    ngx_str_t               zlogin; /* the hack suffix "/wm" or "/ni" or "/tb" */
     ngx_str_t               passwd;
+    ngx_str_t               id_name;    /* the value of "name" field in IMAP ID */
+    ngx_str_t               id_version; /* the value of "version" field in IMAP ID */
 
     ngx_str_t               salt;
     ngx_str_t               tag;
@@ -248,11 +297,31 @@
     u_char                 *arg_start;
     u_char                 *arg_end;
     ngx_uint_t              literal_len;
+    ngx_uint_t              eargs;          /* expected #args for command */
+
+    /* SASL */
+    ngx_flag_t              usedauth;
+    ngx_flag_t              qualifydauth;
+    ngx_str_t               dusr;
+    ngx_str_t               zusr;
+    ngx_str_t               dpasswd;
+    ngx_auth_e              authmech;
+    ngx_flag_t              saslfr;
+    sasl_conn_t            *saslconn;
+    ngx_str_t               authid;         /* SASL authenticating user */
+
+    /* memcache keys */
+    ngx_str_t               key_alias;
+    ngx_str_t               key_route;
+
+    /* clean up */
+    ngx_mail_cleanup_t    *cleanup;
 } ngx_mail_session_t;
 
 
 typedef struct {
     ngx_str_t              *client;
+    ngx_uint_t             client_port;
     ngx_mail_session_t     *session;
 } ngx_mail_log_ctx_t;
 
@@ -280,10 +349,10 @@
 #define NGX_IMAP_NOOP          4
 #define NGX_IMAP_STARTTLS      5
 
-#define NGX_IMAP_NEXT          6
+#define NGX_IMAP_ID            6
 
 #define NGX_IMAP_AUTHENTICATE  7
-
+#define NGX_IMAP_NEXT          8
 
 #define NGX_SMTP_HELO          1
 #define NGX_SMTP_EHLO          2
@@ -306,17 +375,29 @@
 #define NGX_MAIL_AUTH_APOP              3
 #define NGX_MAIL_AUTH_CRAM_MD5          4
 #define NGX_MAIL_AUTH_NONE              5
-
+/* zimbra extension definition */
+#define NGX_MAIL_AUTH_PASSWD            6
+#define NGX_MAIL_AUTH_PLAIN_IR          7
+#define NGX_MAIL_AUTH_GSSAPI            8
+#define NGX_MAIL_AUTH_GSSAPI_IR         9
 
 #define NGX_MAIL_AUTH_PLAIN_ENABLED     0x0002
 #define NGX_MAIL_AUTH_LOGIN_ENABLED     0x0004
 #define NGX_MAIL_AUTH_APOP_ENABLED      0x0008
 #define NGX_MAIL_AUTH_CRAM_MD5_ENABLED  0x0010
-#define NGX_MAIL_AUTH_NONE_ENABLED      0x0020
+#define NGX_MAIL_AUTH_GSSAPI_ENABLED    0x0020
+#define NGX_MAIL_AUTH_NONE_ENABLED      0x0040
 
 
-#define NGX_MAIL_PARSE_INVALID_COMMAND  20
+#define NGX_MAIL_PARSE_INVALID_COMMAND   20
+#define NGX_MAIL_PARSE_INVALID_AUTH_MECH 30
+#define NGX_MAIL_AUTH_ABORT              40
+#define NGX_MAIL_AUTH_ARGUMENT           50
+#define NGX_MAIL_AUTH_FAILED             60
+#define NGX_MAIL_LOGIN_FAILED            70
 
+#define NGX_MAIL_MAX_LOGIN_LEN           256
+#define NGX_MAIL_MAX_PASSWORD_LEN        1024
 
 typedef void (*ngx_mail_init_session_pt)(ngx_mail_session_t *s,
     ngx_connection_t *c);
@@ -336,6 +417,7 @@
     ngx_mail_auth_state_pt      auth_state;
 
     ngx_str_t                   internal_server_error;
+    ngx_str_t                   quit_msg;
 };
 
 
@@ -395,13 +477,27 @@
 ngx_int_t ngx_mail_auth_cram_md5_salt(ngx_mail_session_t *s,
     ngx_connection_t *c, char *prefix, size_t len);
 ngx_int_t ngx_mail_auth_cram_md5(ngx_mail_session_t *s, ngx_connection_t *c);
+ngx_int_t ngx_mail_auth_gssapi(ngx_mail_session_t *s, ngx_connection_t *c, ngx_str_t * output);
 ngx_int_t ngx_mail_auth_parse(ngx_mail_session_t *s, ngx_connection_t *c);
 
 void ngx_mail_send(ngx_event_t *wev);
 ngx_int_t ngx_mail_read_command(ngx_mail_session_t *s, ngx_connection_t *c);
+void ngx_mail_set_imap_parse_state_start(ngx_mail_session_t * s);
+void ngx_mail_set_pop3_parse_state_start(ngx_mail_session_t * s);
+void ngx_mail_set_smtp_parse_state_start(ngx_mail_session_t * s);
+void ngx_mail_set_imap_parse_state_argument(ngx_mail_session_t * s);
+void ngx_mail_set_pop3_parse_state_argument(ngx_mail_session_t * s);
+void ngx_mail_set_smtp_parse_state_argument(ngx_mail_session_t * s);
+void ngx_mail_reset_parse_buffer(ngx_mail_session_t * s);
 void ngx_mail_auth(ngx_mail_session_t *s, ngx_connection_t *c);
+void ngx_mail_do_auth(ngx_mail_session_t *s, ngx_connection_t *c); /* Zimbra mail auth portal */
 void ngx_mail_close_connection(ngx_connection_t *c);
 void ngx_mail_session_internal_server_error(ngx_mail_session_t *s);
+void ngx_mail_end_session(ngx_mail_session_t *s);
+ngx_str_t ngx_mail_session_getquitmsg(ngx_mail_session_t *s);
+ngx_str_t ngx_mail_session_geterrmsg(ngx_mail_session_t *s);
+ngx_str_t ngx_mail_get_socket_local_addr_str (ngx_pool_t *pool, ngx_socket_t s);
+ngx_int_t ngx_mail_decode_auth_plain(ngx_mail_session_t *s, ngx_str_t *encoded);
 u_char *ngx_mail_log_error(ngx_log_t *log, u_char *buf, size_t len);
 
 
@@ -412,7 +508,9 @@
 void ngx_mail_proxy_init(ngx_mail_session_t *s, ngx_addr_t *peer);
 void ngx_mail_auth_http_init(ngx_mail_session_t *s);
 /**/
+ngx_mail_cleanup_t * ngx_mail_cleanup_add(ngx_mail_session_t * s, size_t size);
 
+ngx_flag_t ngx_mail_get_proxy_ssl(ngx_mail_session_t *s);
 
 extern ngx_uint_t    ngx_mail_max_module;
 extern ngx_module_t  ngx_mail_core_module;
diff -ur nginx-1.7.1/src/mail/ngx_mail_auth_http_module.c nginx-1.7.1-zimbra/src/mail/ngx_mail_auth_http_module.c
--- nginx-1.7.1/src/mail/ngx_mail_auth_http_module.c	2014-05-27 06:58:10.000000000 -0700
+++ nginx-1.7.1-zimbra/src/mail/ngx_mail_auth_http_module.c	2014-07-23 12:24:10.000000000 -0700
@@ -1339,7 +1339,7 @@
         conf->peer = prev->peer;
         conf->host_header = prev->host_header;
         conf->uri = prev->uri;
-
+        /* zimbra uses zmauth, so no auth_http
         if (conf->peer == NULL) {
             ngx_log_error(NGX_LOG_EMERG, cf->log, 0,
                           "no \"auth_http\" is defined for server in %s:%ui",
@@ -1347,6 +1347,7 @@
 
             return NGX_CONF_ERROR;
         }
+        */
     }
 
     ngx_conf_merge_msec_value(conf->timeout, prev->timeout, 60000);
diff -ur nginx-1.7.1/src/mail/ngx_mail_core_module.c nginx-1.7.1-zimbra/src/mail/ngx_mail_core_module.c
--- nginx-1.7.1/src/mail/ngx_mail_core_module.c	2014-05-27 06:58:10.000000000 -0700
+++ nginx-1.7.1-zimbra/src/mail/ngx_mail_core_module.c	2014-07-23 12:24:10.000000000 -0700
@@ -89,6 +89,55 @@
       offsetof(ngx_mail_core_srv_conf_t, resolver_timeout),
       NULL },
 
+    /*{ ngx_string("master_auth_username"),
+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_core_srv_conf_t, master_auth_username),
+      NULL },
+
+    { ngx_string("master_auth_password"),
+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_core_srv_conf_t, master_auth_password),
+      NULL },*/
+
+    { ngx_string("sasl_app_name"),
+      NGX_MAIL_MAIN_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_core_srv_conf_t, sasl_app_name),
+      NULL },
+
+    { ngx_string("sasl_service_name"),
+      NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_core_srv_conf_t, sasl_service_name),
+      NULL },
+
+    { ngx_string("zm_auth_wait"),
+      NGX_MAIL_MAIN_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_msec_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_core_srv_conf_t, auth_wait_intvl),
+      NULL },
+
+    { ngx_string("default_realm"),
+      NGX_MAIL_MAIN_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_core_srv_conf_t, default_realm),
+      NULL },
+
+    { ngx_string("sasl_host_from_ip"),
+      NGX_MAIL_MAIN_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_flag_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_core_srv_conf_t, sasl_host_from_ip),
+      NULL },
+
       ngx_null_command
 };
 
@@ -163,11 +212,14 @@
      *     cscf->protocol = NULL;
      */
 
+    cscf->protocol = NGX_CONF_UNSET_PTR;
     cscf->timeout = NGX_CONF_UNSET_MSEC;
     cscf->resolver_timeout = NGX_CONF_UNSET_MSEC;
     cscf->so_keepalive = NGX_CONF_UNSET;
 
     cscf->resolver = NGX_CONF_UNSET_PTR;
+    cscf->auth_wait_intvl = NGX_CONF_UNSET_MSEC;
+    cscf->sasl_host_from_ip = NGX_CONF_UNSET;
 
     cscf->file_name = cf->conf_file->file.name.data;
     cscf->line = cf->conf_file->line;
@@ -188,6 +240,27 @@
 
     ngx_conf_merge_value(conf->so_keepalive, prev->so_keepalive, 0);
 
+    ngx_conf_merge_str_value(
+        conf->sasl_app_name, prev->sasl_app_name, "nginx");
+
+    ngx_conf_merge_str_value(
+        conf->sasl_service_name, prev->sasl_service_name, "");
+/* TO BE HANDLED */
+    if (conf->sasl_service_name.len == 0) {
+        if (conf->protocol->type == NGX_MAIL_IMAP_PROTOCOL) {
+            conf->sasl_service_name.data = (u_char *)"imap";
+            conf->sasl_service_name.len = sizeof("imap") - 1;
+        } else if (conf->protocol->type == NGX_MAIL_POP3_PROTOCOL) {
+            conf->sasl_service_name.data = (u_char *)"pop";
+            conf->sasl_service_name.len = sizeof("pop") - 1;
+        } else if (conf->protocol->type == NGX_MAIL_SMTP_PROTOCOL) {
+            conf->sasl_service_name.data = (u_char *)"smtp";
+            conf->sasl_service_name.len = sizeof("smtp") - 1;
+        } else {
+            conf->sasl_service_name.data = (u_char *)"unknown";
+            conf->sasl_service_name.len = sizeof("unknown") - 1;
+        }
+    }
 
     ngx_conf_merge_str_value(conf->server_name, prev->server_name, "");
 
@@ -202,6 +275,16 @@
         return NGX_CONF_ERROR;
     }
 
+    /*
+     * master_auth_username and master_auth_password is already set in ngx_zm_lookup module
+     *
+     * ngx_conf_merge_str_value(conf->master_auth_username, prev->master_auth_username, "");
+     * ngx_conf_merge_str_value(conf->master_auth_password, prev->master_auth_password, "");
+     */
+    ngx_conf_merge_msec_value (conf->auth_wait_intvl, prev->auth_wait_intvl, 10000);
+
+    ngx_conf_merge_str_value (conf->default_realm, prev->default_realm,"");
+    ngx_conf_merge_value (conf->sasl_host_from_ip, prev->sasl_host_from_ip, 0);
     ngx_conf_merge_ptr_value(conf->resolver, prev->resolver, NULL);
 
     return NGX_CONF_OK;
@@ -651,3 +734,34 @@
 
     return NGX_CONF_OK;
 }
+
+ngx_mail_cleanup_t *
+ngx_mail_cleanup_add(ngx_mail_session_t *s, size_t size)
+{
+    ngx_mail_cleanup_t  *cln;
+
+    cln = ngx_palloc(s->connection->pool, sizeof(ngx_mail_cleanup_t));
+    if (cln == NULL) {
+        return NULL;
+    }
+
+    if (size) {
+        cln->data = ngx_palloc(s->connection->pool, size);
+        if (cln->data == NULL) {
+            return NULL;
+        }
+
+    } else {
+        cln->data = NULL;
+    }
+
+    cln->handler = NULL;
+    cln->next = s->cleanup;
+
+    s->cleanup = cln;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+                   "mail cleanup add: %p", cln);
+
+    return cln;
+}
diff -ur nginx-1.7.1/src/mail/ngx_mail_handler.c nginx-1.7.1-zimbra/src/mail/ngx_mail_handler.c
--- nginx-1.7.1/src/mail/ngx_mail_handler.c	2014-05-27 06:58:10.000000000 -0700
+++ nginx-1.7.1-zimbra/src/mail/ngx_mail_handler.c	2014-07-23 12:24:10.000000000 -0700
@@ -10,20 +10,43 @@
 #include <ngx_event.h>
 #include <ngx_mail.h>
 
+#include <sasl/sasl.h>
+#include <sasl/saslplug.h>
+#include <ngx_mail_throttle_module.h>
+#include <ngx_mail_pop3_module.h>
+#include <ngx_mail_smtp_module.h>
+#include <ngx_mail_zmauth_module.h>
 
 static void ngx_mail_init_session(ngx_connection_t *c);
+static void ngx_mail_choke_session(throttle_callback_t *cb);
+static void ngx_mail_allow_session(throttle_callback_t *cb);
+static void ngx_mail_allow_userauth(throttle_callback_t *cb);
+static void ngx_mail_choke_userauth(throttle_callback_t *cb);
 
 #if (NGX_MAIL_SSL)
 static void ngx_mail_ssl_init_connection(ngx_ssl_t *ssl, ngx_connection_t *c);
 static void ngx_mail_ssl_handshake_handler(ngx_connection_t *c);
 #endif
 
+static int ngx_mail_create_sasl_context(ngx_connection_t *s);
+static void ngx_mail_dispose_sasl_context(ngx_mail_session_t *s);
+static int ngx_mail_initialize_sasl(ngx_connection_t *c);
+static int ngx_mail_sasl_startstep(ngx_connection_t *c, const char *mech,
+    ngx_str_t  *response, ngx_str_t  *challenge);
+static int ngx_mail_sasl_log(void *context, int level, const char * message);
+static int ngx_mail_sasl_pauthorize(sasl_conn_t *conn, void *context,
+    const char *authz, unsigned authzlen, const char *authc, unsigned authclen,
+    const char *realm, unsigned rlen, struct propctx *propctx);
+
+static ngx_str_t    krb5_cooked_password = ngx_string("KKK");
+
+static ngx_flag_t sasl_initialized = 0;
 
 void
 ngx_mail_init_connection(ngx_connection_t *c)
 {
-    size_t                 len;
     ngx_uint_t             i;
+    ngx_uint_t            remote_port=0;
     ngx_mail_port_t       *port;
     struct sockaddr       *sa;
     struct sockaddr_in    *sin;
@@ -31,7 +54,7 @@
     ngx_mail_in_addr_t    *addr;
     ngx_mail_session_t    *s;
     ngx_mail_addr_conf_t  *addr_conf;
-    u_char                 text[NGX_SOCKADDR_STRLEN];
+    //u_char                 text[NGX_SOCKADDR_STRLEN];
 #if (NGX_HAVE_INET6)
     struct sockaddr_in6   *sin6;
     ngx_mail_in6_addr_t   *addr6;
@@ -129,10 +152,28 @@
     c->data = s;
     s->connection = c;
 
-    len = ngx_sock_ntop(c->sockaddr, c->socklen, text, NGX_SOCKADDR_STRLEN, 1);
+    //len = ngx_sock_ntop(c->sockaddr, c->socklen, text, NGX_SOCKADDR_STRLEN, 1);
+
+    switch (c->sockaddr->sa_family) {
+#if (NGX_HAVE_INET6)
+        case AF_INET6:
+            sin6 = (struct sockaddr_in6 *) c->sockaddr;
+            remote_port = ntohs(sin6->sin6_port);
+            break;
+#endif
+        default:
+            sin = (struct sockaddr_in *) c->sockaddr;
+            remote_port = ntohs(sin->sin_port);
+            break;
+    }
 
-    ngx_log_error(NGX_LOG_INFO, c->log, 0, "*%uA client %*s connected to %V",
-                  c->number, len, text, s->addr_text);
+    if (remote_port && remote_port < 65536) {
+    	ngx_log_error(NGX_LOG_INFO, c->log, 0, "*%ui client %V:%ui connected to %V",
+    			c->number, &c->addr_text, remote_port, s->addr_text);
+    } else {
+    	ngx_log_error(NGX_LOG_INFO, c->log, 0, "*%ui client %V connected to %V",
+    			c->number, &c->addr_text, s->addr_text);
+    }
 
     ctx = ngx_palloc(c->pool, sizeof(ngx_mail_log_ctx_t));
     if (ctx == NULL) {
@@ -141,6 +182,7 @@
     }
 
     ctx->client = &c->addr_text;
+    ctx->client_port = remote_port;
     ctx->session = s;
 
     c->log->connection = c->number;
@@ -273,10 +315,13 @@
 {
     ngx_mail_session_t        *s;
     ngx_mail_core_srv_conf_t  *cscf;
+    ngx_mail_throttle_srv_conf_t *tscf;
+    throttle_callback_t       *cb;
 
     s = c->data;
 
     cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);
+    tscf = ngx_mail_get_module_srv_conf(s, ngx_mail_throttle_module);
 
     s->protocol = cscf->protocol->type;
 
@@ -286,18 +331,243 @@
         return;
     }
 
+    s->cleanup = NULL;
+
+    /* throttle */
+    cb = ngx_pcalloc(c->pool, sizeof(throttle_callback_t));
+    if(cb == NULL) {
+        ngx_mail_session_internal_server_error(s);
+        return;
+    }
+
+    ngx_memset(cb, 0, sizeof(throttle_callback_t));
+    cb->session = s;
+    cb->connection = c;
+    cb->log = ngx_cycle->log;
+    cb->pool = c->pool;
+    cb->on_allow = ngx_mail_allow_session;
+    cb->on_deny = ngx_mail_choke_session;
+
+    if (tscf->mail_login_ip_max == 0) {
+        cb->on_allow(cb); //unlimited, direct allow session
+    } else {
+        ngx_mail_throttle_ip(c->addr_text, cb);
+    }
+}
+
+static void
+ngx_mail_choke_session(throttle_callback_t *cb)
+{
+    ngx_connection_t             *c;
+    ngx_mail_session_t           *s;
+    ngx_mail_throttle_srv_conf_t *tscf;
+    ngx_str_t                     bye, msg;
+    u_char                       *p;
+
+    c = (ngx_connection_t *)cb->connection;
+    s = c->data;
+    tscf = ngx_mail_get_module_srv_conf(s, ngx_mail_throttle_module);
+    msg = tscf->mail_login_ip_rejectmsg;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log,0,
+        "ip throttle:%V choking mail session", &c->addr_text);
+
+    if(s->protocol == NGX_MAIL_IMAP_PROTOCOL) {
+        bye.data = 
+        ngx_palloc(c->pool, 
+            sizeof("* BYE ")- 1 +
+            msg.len +
+            sizeof(CRLF) - 1
+            );
+        if (bye.data == NULL) {
+            ngx_str_set(&bye, "* BYE" CRLF);
+        } else {
+            p = bye.data;
+            p = ngx_cpymem(p, "* BYE ", sizeof("* BYE ") - 1);
+            p = ngx_cpymem(p, msg.data, msg.len);
+            *p++ = CR;
+            *p++ = LF;
+            bye.len = p - bye.data;
+        }
+    } else if(s->protocol == NGX_MAIL_POP3_PROTOCOL) {
+        bye.data = ngx_palloc(c->pool, 
+                       sizeof("-ERR ") - 1 +
+                       msg.len +
+                       sizeof(CRLF) - 1);
+        if (bye.data == NULL) {
+            ngx_str_set(&bye, "-ERR" CRLF);
+        } else {
+            p = bye.data;
+            p = ngx_cpymem(p,"-ERR ",sizeof("-ERR ") - 1);
+            p = ngx_cpymem(p, msg.data, msg.len);
+            *p++ = CR;
+            *p++ = LF;
+            bye.len = p - bye.data;
+        }
+    } else {
+        /* TODO SMTP is not (yet) relevant for zimbra, but how do we reject it ? */
+        ngx_str_set(&bye, "");
+    }
+
+    s->out = bye;
+    s->quit = 1;
+
+    ngx_mail_send(c->write);
+
+    return;
+}
+
+static void
+ngx_mail_allow_session(throttle_callback_t *cb)
+{
+    ngx_connection_t            *c;
+    ngx_mail_session_t          *s;
+    ngx_mail_core_srv_conf_t    *cscf;
+
+    c = (ngx_connection_t*)cb->connection;
+    s = c->data;
+    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);
+
     c->write->handler = ngx_mail_send;
 
     cscf->protocol->init_session(s, c);
 }
 
+static void
+ngx_mail_choke_userauth(throttle_callback_t *cb)
+{
+    ngx_connection_t             *c;
+    ngx_mail_session_t           *s;
+    ngx_mail_throttle_srv_conf_t *tscf;
+    ngx_str_t                     bye, msg, umsg;
+    size_t                        l;
+    u_char                       *p;
+
+    c = (ngx_connection_t *)cb->connection;
+    s = c->data;
+    tscf = ngx_mail_get_module_srv_conf(s, ngx_mail_throttle_module);
+    msg = tscf->mail_login_user_rejectmsg;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,
+        "user throttle:%V choking mail session", &s->login);
+
+    if(s->protocol == NGX_MAIL_IMAP_PROTOCOL)
+    {
+        bye.data = ngx_palloc(c->pool, sizeof("* BYE ") - 1 +
+                              msg.len + sizeof(CRLF) - 1);
+        if (bye.data == NULL) {
+            ngx_str_set(&bye, "* BYE" CRLF);
+        } else {
+            p = bye.data;
+            p = ngx_cpymem(p, "* BYE ", sizeof("* BYE ") - 1);
+            p = ngx_cpymem(p, msg.data, msg.len);
+            *p++ = CR;
+            *p++ = LF;
+            bye.len = p - bye.data;
+        }
+        s->out = bye;
+        s->quit = 0;            /* don't quit just yet */
+        ngx_mail_send(c->write);
+
+        /* for IMAP, we also want to send back a tagged NO response */
+        l = s->tag.len + 1 /*for space*/ +
+            sizeof("NO ") - 1 +
+            sizeof(" failed") - 1 +       /* ?? "failed" or "rejected" ?? */
+            sizeof(CRLF) - 1;
+
+        if (s->command == NGX_IMAP_LOGIN) {
+            l += (sizeof("LOGIN ") - 1);
+        } else if (s->command == NGX_IMAP_AUTHENTICATE) {
+            l += (sizeof("AUTHENTICATE ") - 1);
+        }
+
+        umsg.data = ngx_palloc(c->pool,l);
+
+        if (umsg.data == NULL) {
+            ngx_str_set(&umsg, "");
+        } else {
+            p = umsg.data;
+            p = ngx_cpymem(p, s->tag.data, s->tag.len);
+            *p++=' ';
+            p = ngx_cpymem(p, "NO ", sizeof("NO ") - 1);
+            if (s->command == NGX_IMAP_LOGIN) {
+                p = ngx_cpymem(p, "LOGIN ", sizeof("LOGIN ") - 1);
+            } else if (s->command == NGX_IMAP_AUTHENTICATE) {
+                p = ngx_cpymem(p, "AUTHENTICATE ", sizeof("AUTHENTICATE ") - 1);
+            }
+            p = ngx_cpymem(p, "failed", sizeof("failed") - 1);
+            *p++ = CR;
+            *p++ = LF;
+            umsg.len = p - umsg.data;
+        }
+
+        s->out = umsg;
+        s->quit = 1;
+        ngx_mail_send(c->write);
+
+        return;
+    }
+    else if(s->protocol == NGX_MAIL_POP3_PROTOCOL)
+    {
+        bye.data = 
+        ngx_palloc(c->pool,
+        sizeof("-ERR ")-1+msg.len+sizeof(CRLF)-1);
+        if (bye.data == NULL) {
+            bye.data = (u_char*)("-ERR" CRLF);
+            bye.len = sizeof("-ERR" CRLF)-1;
+        } else {
+            p = bye.data;
+            p = ngx_cpymem(p,"-ERR ",sizeof("-ERR ")-1);
+            p = ngx_cpymem(p,msg.data,msg.len);
+            *p++ = CR;
+            *p++ = LF;
+            bye.len = p-bye.data;
+        }
+        s->out = bye;
+        s->quit = 1;
+        ngx_mail_send(c->write);
+        return;
+    }
+    else
+    {
+        /* TODO SMTP is not (yet) relevant for zimbra, but how do we reject it ? */
+        ngx_str_set(&bye, "");
+        s->out = bye;
+        s->quit = 1;
+        ngx_mail_send(c->write);
+        return;
+    }
+}
+
+static void
+ngx_mail_allow_userauth(throttle_callback_t *cb)
+{
+    ngx_connection_t            *c;
+    ngx_mail_session_t          *s;
+
+    c = (ngx_connection_t *)cb->connection;
+    s = c->data;
+
+    /* remainder code is the erstwhile ngx_mail_do_auth(s);*/
+    s->args.nelts = 0;
+    s->buffer->pos = s->buffer->start;
+    s->buffer->last = s->buffer->start;
+    s->state = 0;
+
+    if (s->connection->read->timer_set) {
+        ngx_del_timer(s->connection->read);
+    }
+
+    s->login_attempt++;
+    ngx_mail_zmauth_init(s);
+}
 
 ngx_int_t
 ngx_mail_salt(ngx_mail_session_t *s, ngx_connection_t *c,
     ngx_mail_core_srv_conf_t *cscf)
 {
     s->salt.data = ngx_pnalloc(c->pool,
-                               sizeof(" <18446744073709551616.@>" CRLF) - 1
+                               sizeof("<18446744073709551616.@>" CRLF) - 1
                                + NGX_TIME_T_LEN
                                + cscf->server_name.len);
     if (s->salt.data == NULL) {
@@ -335,13 +605,41 @@
 #endif
 
 
+/* Decode an SASL PLAIN challenge (RFC 4616)
+   If AUTHZ is empty:
+    set s->usedauth = 0, 
+    set s->login = AUTHC
+   If AUTHZ is present:
+    set s->usedauth = 1
+    set s->dusr = AUTHC
+    set s->login = AUTHZ
+ */
 ngx_int_t
 ngx_mail_auth_plain(ngx_mail_session_t *s, ngx_connection_t *c, ngx_uint_t n)
 {
     u_char     *p, *last;
-    ngx_str_t  *arg, plain;
+    ngx_str_t  *arg, plain, temp;
 
     arg = s->args.elts;
+    
+#if (NGX_MAIL_SSL)
+    if(ngx_mail_starttls_only(s, c)) {
+    	return NGX_MAIL_PARSE_INVALID_COMMAND;
+    }
+#endif
+
+    /* check if the auth exchange is being aborted */
+    if (s->args.nelts > 0 &&
+        arg[n].len == 1 &&
+        arg[n].data[0] == '*'
+       )
+    {
+        ngx_log_debug0 (NGX_LOG_DEBUG_MAIL, c->log, 0,
+            "auth:abort SASL PLAIN");
+
+        ngx_mail_dispose_sasl_context(s);
+        return NGX_MAIL_AUTH_ABORT;
+    }
 
 #if (NGX_DEBUG_MAIL_PASSWD)
     ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,
@@ -359,6 +657,8 @@
         return NGX_MAIL_PARSE_INVALID_COMMAND;
     }
 
+    s->auth_method = NGX_MAIL_AUTH_PLAIN;
+
     p = plain.data;
     last = p + plain.len;
 
@@ -370,6 +670,9 @@
         return NGX_MAIL_PARSE_INVALID_COMMAND;
     }
 
+    s->dusr.data = plain.data;
+    s->dusr.len = p - plain.data - 1;
+
     s->login.data = p;
 
     while (p < last && *p) { p++; }
@@ -385,11 +688,29 @@
     s->passwd.len = last - p;
     s->passwd.data = p;
 
+    if (s->login.len > NGX_MAIL_MAX_LOGIN_LEN ||
+        s->dusr.len > NGX_MAIL_MAX_LOGIN_LEN ||
+        s->passwd.len > NGX_MAIL_MAX_PASSWORD_LEN) {
+        return NGX_MAIL_AUTH_FAILED;
+    }
+
 #if (NGX_DEBUG_MAIL_PASSWD)
     ngx_log_debug2(NGX_LOG_DEBUG_MAIL, c->log, 0,
                    "mail auth plain: \"%V\" \"%V\"", &s->login, &s->passwd);
 #endif
 
+    if (s->dusr.len == 0) {
+        /* s->dusr = s->login; */
+        s->usedauth = 0;
+    } else {
+        s->usedauth = 1;
+        temp = s->dusr;
+        s->dusr = s->login;
+        s->login = temp;
+    }
+
+    s->dpasswd = s->passwd;
+    
     return NGX_DONE;
 }
 
@@ -405,6 +726,23 @@
     ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,
                    "mail auth login username: \"%V\"", &arg[n]);
 
+
+    /* check if the auth exchange is being aborted */
+    if (s->args.nelts > 0 &&
+        arg[n].len == 1 &&
+        arg[n].data[0] == '*'
+       )
+    {
+        ngx_log_debug0 (NGX_LOG_DEBUG_MAIL, c->log, 0,
+            "auth:abort SASL LOGIN");
+
+        ngx_mail_dispose_sasl_context(s);
+        return NGX_MAIL_AUTH_ABORT;
+    }
+
+    if (ngx_base64_decoded_length(arg->len) > NGX_MAIL_MAX_LOGIN_LEN) {
+        return NGX_MAIL_AUTH_FAILED;
+    }
     s->login.data = ngx_pnalloc(c->pool, ngx_base64_decoded_length(arg[n].len));
     if (s->login.data == NULL) {
         return NGX_ERROR;
@@ -419,7 +757,7 @@
     ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,
                    "mail auth login username: \"%V\"", &s->login);
 
-    return NGX_OK;
+    return NGX_MAIL_AUTH_ARGUMENT;
 }
 
 
@@ -434,7 +772,21 @@
     ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,
                    "mail auth login password: \"%V\"", &arg[0]);
 #endif
+    /* check if the auth exchange is being aborted */
+    if (s->args.nelts > 0 && 
+        arg[0].len == 1 &&
+        arg[0].data[0] == '*'
+       ) {
+        ngx_log_debug0 (NGX_LOG_DEBUG_MAIL, c->log, 0,
+            "auth:abort SASL LOGIN");
 
+        ngx_mail_dispose_sasl_context(s);
+        return NGX_MAIL_AUTH_ABORT;
+    }
+
+    if(ngx_base64_decoded_length(arg[0].len) > NGX_MAIL_MAX_PASSWORD_LEN) {
+        return NGX_MAIL_AUTH_FAILED;
+    }
     s->passwd.data = ngx_pnalloc(c->pool,
                                  ngx_base64_decoded_length(arg[0].len));
     if (s->passwd.data == NULL) {
@@ -452,6 +804,9 @@
                    "mail auth login password: \"%V\"", &s->passwd);
 #endif
 
+    s->auth_method = NGX_MAIL_AUTH_LOGIN;
+    s->usedauth = 0;
+
     return NGX_DONE;
 }
 
@@ -529,10 +884,719 @@
                    "mail auth cram-md5: \"%V\" \"%V\"", &s->login, &s->passwd);
 
     s->auth_method = NGX_MAIL_AUTH_CRAM_MD5;
+    s->usedauth = 0;
 
     return NGX_DONE;
 }
 
+ngx_int_t
+ngx_mail_auth_gssapi(ngx_mail_session_t *s, ngx_connection_t *c, ngx_str_t * output)
+{
+    ngx_str_t  *args, *arg;
+    ngx_uint_t narg;
+    ngx_mail_core_srv_conf_t *cscf;
+    int saslrc;
+
+    args = s->args.elts;
+    narg = s->args.nelts;
+    arg = args + narg - 1;
+
+    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);
+
+    /* check if the auth exchange is being aborted */
+    if (narg > 0 && 
+        arg->len == 1 &&
+        arg->data[0] == '*'
+       )
+    {
+        ngx_log_debug0 (NGX_LOG_DEBUG_MAIL,c->log,0,
+            "auth:abort SASL GSSAPI");
+
+        ngx_mail_dispose_sasl_context(s);
+        return NGX_MAIL_AUTH_ABORT;
+    }
+
+    /* Initialize SASL once per process */
+    saslrc = ngx_mail_initialize_sasl (c);
+
+    if (saslrc != SASL_OK) {
+        return NGX_ERROR;
+    }
+
+    /* create one sasl authentication object per connection */
+    saslrc = ngx_mail_create_sasl_context (c);
+
+    if (saslrc != SASL_OK) {
+        return NGX_ERROR;
+    }
+
+    saslrc = ngx_mail_sasl_startstep(c,"gssapi", arg, output);
+
+    if (saslrc == SASL_CONTINUE)
+    {
+        return NGX_MAIL_AUTH_ARGUMENT;
+    }
+    else if (saslrc == SASL_OK)
+    {
+        s->dusr = cscf->master_auth_username;
+        s->dpasswd = cscf->master_auth_password;
+        s->auth_method = NGX_MAIL_AUTH_GSSAPI;
+        s->passwd = krb5_cooked_password;
+        s->usedauth = 1;
+        return NGX_DONE;
+    }
+    else
+    {
+        return NGX_ERROR;
+    }
+}
+
+/* Perform a once-per-process initialization of the sasl library */
+static int
+ngx_mail_initialize_sasl (ngx_connection_t *c)
+{
+    ngx_mail_session_t          *s;
+    ngx_mail_core_srv_conf_t    *cscf;
+    int                          rc = SASL_OK;
+    char                        *app;
+
+    if (!sasl_initialized)
+    {
+        s = c->data;
+        cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);
+
+        app = ngx_palloc(c->pool, cscf->sasl_app_name.len + 1);
+
+        if (app == NULL) { return SASL_FAIL; }
+
+        ngx_memcpy (app, cscf->sasl_app_name.data, cscf->sasl_app_name.len);
+        ngx_memcpy (app + cscf->sasl_app_name.len, "\x0", 1);
+
+        ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, c->log, 0,
+            "Initializing SASL library, app:%s", app);
+
+        rc = sasl_server_init (NULL, app);
+
+        if (rc != SASL_OK)
+        {
+            ngx_log_error (NGX_LOG_ERR, c->log, 0,
+                "Cannot initialize SASL library: err:%d, %s",
+                rc, sasl_errstring(rc,NULL,NULL)
+            );
+        }
+        else
+        {
+            ngx_log_debug0 (NGX_LOG_DEBUG_MAIL, c->log, 0,
+                "Initialized SASL library");
+            sasl_initialized = 1;
+        }
+    }
+
+    return rc;
+}
+
+/*
+static int ngx_mail_canonicalize_user (
+    sasl_conn_t *conn,
+    void *context,
+    const char *in,
+    unsigned inlen,
+    unsigned flags,
+    const char *realm,
+    char *out,
+    unsigned out_max,
+    unsigned *out_len
+)
+{
+    ngx_connection_t            *c = context;
+    ngx_mail_session_t          *s = c->data;
+    ngx_mail_core_srv_conf_t    *cscf = 
+        ngx_mail_get_module_srv_conf(s,ngx_mail_core_module);
+    ngx_str_t            v,R;
+
+    ngx_log_debug0 (NGX_LOG_DEBUG_MAIL,c->log,0,
+        "sasl: canonicalizing user name(s)");
+
+    if (realm == NULL) {
+        ngx_log_debug1 (NGX_LOG_DEBUG_MAIL,c->log,0,
+            "sasl: SASL layer did not provide realm, will use:%V",
+            &cscf->default_realm);
+        R = cscf->default_realm;
+    } else {
+        ngx_log_debug1 (NGX_LOG_DEBUG_MAIL,c->log,0,
+            "sasl: will use realm:%s", realm);
+        R.data = (u_char *)realm;
+        R.len = strlen(realm);
+    }
+
+    if (((flags & SASL_CU_AUTHID) != 0) || ((flags & SASL_CU_AUTHZID) != 0))
+    {
+        v.data = (u_char *)in;
+        v.len = inlen;
+
+        if ((flags & SASL_CU_AUTHID) == 0) {
+            ngx_log_debug1 (NGX_LOG_DEBUG_MAIL,c->log,0,
+                "sasl: canonicalizing authzid:%V", &v);
+        } else if ((flags & SASL_CU_AUTHZID) == 0) {
+            ngx_log_debug1 (NGX_LOG_DEBUG_MAIL,c->log,0,
+                "sasl: canonicalizing authcid:%V", &v);
+        } else {
+            ngx_log_debug2 (NGX_LOG_DEBUG_MAIL,c->log,0,
+                "sasl: canonicalizing authzid:%V, authcid:%V", &v, &v);
+        }
+
+        if (R.len == 0) {
+            if (out_max >= inlen) {
+                ngx_memcpy(out,in,inlen);
+                *out_len = inlen;
+                return SASL_OK;
+            } else {
+                return SASL_NOMEM;
+            }
+        } else {
+            if (out_max >= (inlen+(sizeof("@")-1)+R.len)) {
+                ngx_memcpy(out,in,inlen);
+                ngx_memcpy(out+inlen,"@",sizeof("@")-1);
+                ngx_memcpy(out+inlen+sizeof("@")-1,R.data,R.len);
+                *out_len = inlen + sizeof("@")-1 + R.len;
+                return SASL_OK;
+            } else {
+                return SASL_NOMEM;
+            }
+        }
+    }
+
+    return SASL_BADPARAM;
+}
+*/
+
+static int
+ngx_mail_sasl_pauthorize (sasl_conn_t *conn, void *context, const char *authz,
+    unsigned authzlen, const char *authc, unsigned authclen, const char *realm,
+    unsigned rlen, struct propctx *propctx)
+{
+    /* this function is called when we need to indicate whether the authz/authc 
+       relationship should be allowed or not
+       ie can authc access authz's mailbox
+       since that decision must be made in the lookup servlet (which will happen later),
+       we need to defer that decision to the route lookup phase, and simply 
+       indicate our consent here
+     */
+
+    ngx_connection_t    *c = context;
+    ngx_str_t            nauthz = ngx_string(""),
+                         nauthc = ngx_string(""),
+                         nrealm = ngx_string("");
+
+    (void)c;
+    if (authz != NULL && authzlen > 0) {
+        nauthz.data = (u_char *)authz;
+        nauthz.len = authzlen;
+    }
+    if (authc != NULL && authclen > 0) {
+        nauthc.data = (u_char *)authc;
+        nauthc.len = authclen;
+    }
+    if (realm != NULL && rlen > 0) {
+        nrealm.data = (u_char *)realm;
+        nrealm.len = rlen;
+    }
+
+    ngx_log_debug3(NGX_LOG_DEBUG_MAIL,c->log,0,
+        "sasl: indicating proxy policy ok, authz:%V,authc:%V,realm:%V",
+        &nauthz,&nauthc,&nrealm
+        );
+
+    return SASL_OK;
+}
+
+static int
+ngx_mail_sasl_log (void *context, int level, const char *message)
+{
+    ngx_connection_t    *c = context;
+
+    (void)c;
+    ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, c->log, 0,
+        "%s", message == NULL ? "null" : message);
+
+    return SASL_OK;
+}
+
+
+/* create a new SASL server authentication object (once per connection) */
+static int
+ngx_mail_create_sasl_context (ngx_connection_t *c)
+{
+    ngx_mail_session_t          *s;
+    ngx_mail_core_srv_conf_t    *cscf;
+    char                        *service;
+    int                          rc = SASL_OK;
+    sasl_security_properties_t   rsec;
+    sasl_callback_t             *callbacks;
+    ngx_uint_t                   i;
+    const char                  *fqdn = NULL;
+    struct hostent              *host;
+    struct sockaddr_in           sa;
+    socklen_t                    salen;
+    u_char                      *octets;
+
+    s = c->data;
+    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);
+
+    if (s->saslconn == NULL)
+    {
+        service = ngx_palloc (c->pool, cscf->sasl_service_name.len + 1);
+        if (service == NULL) {
+            return SASL_FAIL;
+        }
+
+        callbacks = ngx_palloc(c->pool,sizeof(sasl_callback_t) * 8);
+        if (callbacks == NULL) {
+            ngx_log_error (NGX_LOG_ERR, c->log, 0, 
+                "cannot alloc memory for SASL callbacks"
+                );
+            return SASL_NOMEM;
+        }
+
+        i =0 ;
+        // XXX using the canon callback is corrupting mem
+        // callbacks[i].id = SASL_CB_CANON_USER;
+        // callbacks[i].proc = ngx_mail_canonicalize_user;
+        // callbacks[i].context = c;
+        // ++i;
+        callbacks[i].id = SASL_CB_LOG;
+        callbacks[i].proc = (sasl_callback_ft)&ngx_mail_sasl_log;
+        callbacks[i].context = c;
+        ++i;
+
+        callbacks[i].id = SASL_CB_PROXY_POLICY;
+        callbacks[i].proc = (sasl_callback_ft)&ngx_mail_sasl_pauthorize;
+        callbacks[i].context = c;
+        ++i;
+
+        callbacks[i].id = SASL_CB_LIST_END;
+        callbacks[i].proc = NULL;
+        callbacks[i].context = NULL;
+        ++i;
+
+        ngx_memcpy (service, cscf->sasl_service_name.data,
+            cscf->sasl_service_name.len);
+        service[cscf->sasl_service_name.len] = 0;
+
+        /* The second argument to sasl_server_new is the FQDN of the server
+           If the srvprinc_from_ip configuration parameter is true, then 
+         */
+
+        if (cscf->sasl_host_from_ip)
+        {
+            ngx_log_error (NGX_LOG_WARN, c->log, 0,
+                "will use IP address to resolve service principal");
+
+            salen = sizeof(sa);
+            if (
+                getsockname(s->connection->fd, (struct sockaddr*)&sa, &salen)
+                == 0
+               )
+            {
+                if (sa.sin_family != AF_INET || salen != sizeof(sa))
+                {
+                    ngx_log_error(NGX_LOG_ERR, c->log, 0,
+                        "non-ipv4 local address of mail connection ignored");
+                }
+                else
+                {
+                    octets = (u_char *)&sa.sin_addr.s_addr;
+
+                    ngx_log_error (NGX_LOG_WARN, c->log, 0,
+                        "entering blocking network call (gethostbyaddr)");
+
+                    host = gethostbyaddr(
+                            &sa.sin_addr,
+                            sizeof(sa.sin_addr),
+                            AF_INET);
+
+                    if (host == NULL)
+                    {
+                        ngx_log_error (NGX_LOG_ERR, c->log, 0,
+                            "cannot lookup host by IP address, err:%d",
+                            h_errno);
+                    }
+                    else
+                    {
+                        ngx_log_error (NGX_LOG_INFO, c->log, 0,
+                            "resolved incoming IP %d.%d.%d.%d to host:%s",
+                            octets[0],
+                            octets[1],
+                            octets[2],
+                            octets[3],
+                            host->h_name);
+
+                        fqdn = host->h_name;
+                    }
+                }
+            }
+            else
+            {
+                ngx_log_error(NGX_LOG_ERR, c->log, 0,
+                    "cannot get local address of mail connection, err:%d",
+                    ngx_errno);
+            }
+        }
+
+        rc = sasl_server_new
+                (
+                    service,
+                    fqdn,
+                    NULL,
+                    NULL,
+                    NULL,
+                    callbacks,
+                    0,
+                    &s->saslconn
+                );
+
+        if (rc != SASL_OK)
+        {
+            ngx_log_error (NGX_LOG_ERR, c->log, 0, 
+                "cannot create SASL context (%V), err:%d,%s",
+                &cscf->sasl_service_name,
+                rc, sasl_errstring (rc,NULL,NULL)
+                );
+            s->saslconn = NULL;
+        }
+        else
+        {
+            const char * mechlist;
+            unsigned     menLen;
+            int          num;
+            rc = sasl_listmech(s->saslconn, NULL, "{", ", ", "}", &mechlist, &menLen, &num);
+            ngx_log_error(NGX_LOG_INFO, c->log,0, "mech list is: %s", mechlist);
+            ngx_log_debug2 (NGX_LOG_DEBUG_MAIL, c->log, 0, 
+                "created SASL context (%V), 0x%p",
+                &cscf->sasl_service_name,
+                s->saslconn
+                );
+
+            rsec.min_ssf = 0;
+            rsec.max_ssf = 0;
+            rsec.maxbufsize = 4096;
+            rsec.property_names = NULL;
+            rsec.property_values = NULL;
+            rsec.security_flags = 0;
+            // SASL_SEC_PASS_CREDENTIALS|SASL_SEC_MUTUAL_AUTH;
+
+            rc = sasl_setprop(s->saslconn, SASL_SEC_PROPS, &rsec);
+        }
+    }
+
+    return rc;
+}
+
+static void
+ngx_mail_dispose_sasl_context (ngx_mail_session_t *s)
+{
+    if (s->saslconn != NULL)
+    {
+        ngx_log_debug1(NGX_LOG_DEBUG_MAIL,s->connection->log,0,
+            "disposing SASL context:%p",s->saslconn);
+        sasl_dispose(&s->saslconn);
+        ngx_log_debug1(NGX_LOG_DEBUG_MAIL,s->connection->log,0,
+            "disposed SASL context:%p",s->saslconn);
+        s->saslconn = NULL;
+    }
+    return;
+}
+
+static int
+ngx_mail_sasl_startstep (
+    ngx_connection_t *c,
+    const char *mech,
+    ngx_str_t  *response,
+    ngx_str_t  *challenge
+    )
+{
+    ngx_mail_session_t          *s;
+    ngx_str_t                    r;
+    int                          rc;
+    const char                  *saslstr,*authc,*authz;
+    unsigned                     sasls;
+    ngx_str_t                    ch64, ch;
+    ngx_mail_core_srv_conf_t    *cscf;
+    u_char                      *p;
+    ngx_flag_t                   inheritAuthZ, needRealm;
+    size_t                       len;
+
+    s = c->data;
+    cscf = ngx_mail_get_module_srv_conf(s,ngx_mail_core_module);
+
+    /* saslfr (fr = first response) indicates whether the client has
+       issued at least one SASL response to the server
+       saslfr starts out as 0, and is immediately set to 1 when the 
+       server starts processing the client responses
+     */
+    if (!s->saslfr)
+    {
+        ngx_log_debug0 (NGX_LOG_DEBUG_MAIL, c->log, 0,
+            "beginning SASL auth negotiation");
+
+        if (response == NULL)
+        {
+            ngx_log_debug0 (NGX_LOG_DEBUG_MAIL, c->log, 0,
+                "using NULL client response");
+
+            r.data = NULL;
+            r.len = 0;
+        }
+        else
+        {
+             ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, c->log, 0,
+                "using response %V", response);
+
+             r.len = ngx_base64_decoded_length (response->len);
+             r.data = ngx_palloc (c->pool, r.len);
+
+             if (r.data == NULL) {
+                return SASL_FAIL;
+             }
+
+             if (ngx_decode_base64 (&r, response) != NGX_OK)
+             {
+                ngx_log_error (NGX_LOG_ERR, c->log, 0,
+                    "invalid base64 response sent by client");
+
+                return SASL_FAIL;
+             }
+             else
+             {
+                ngx_log_debug2 (NGX_LOG_DEBUG_MAIL, c->log, 0,
+                    "%d bytes of base64-challenge decoded to %d sasl-bytes",
+                    response->len, r.len);
+             }
+        }
+
+        rc = sasl_server_start
+                (
+                    s->saslconn,
+                    mech,
+                    (char *)r.data,
+                    r.len,
+                    &saslstr,
+                    &sasls
+                );
+
+        s->saslfr = 1;
+    }
+    else
+    {
+         ngx_log_debug0 (NGX_LOG_DEBUG_MAIL, c->log, 0,
+            "continuing SASL auth negotiation");
+
+         r.len = ngx_base64_decoded_length (response->len);
+         r.data = ngx_palloc (c->pool, r.len);
+
+         if (r.data == NULL) {
+            return SASL_FAIL;
+         }
+
+         if (ngx_decode_base64 (&r, response) != NGX_OK)
+         {
+            ngx_log_error (NGX_LOG_ERR, c->log, 0,
+                "invalid base64 response sent by client");
+
+            return SASL_FAIL;
+         }
+ 
+         rc = sasl_server_step
+                (
+                    s->saslconn,
+                    (char *)r.data,
+                    r.len,
+                    &saslstr,
+                    &sasls
+                );
+    }
+
+    if ((rc != SASL_OK) && (rc != SASL_CONTINUE))
+    {
+        ngx_log_error (NGX_LOG_ERR, c->log, 0,
+            "SASL auth negotiation failed, err:%d (%s)",
+            rc, sasl_errstring(rc,NULL,NULL));
+    }
+    else
+    {
+        /* construct the challenge depending upon the protocol */
+
+        ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, c->log, 0,
+            "constructing protocol specific response for %d bytes of challenge",
+            sasls);
+
+        if (saslstr == NULL || sasls == 0)
+        {
+            ch64.data = (u_char *)"";
+            ch64.len = 0;
+        }
+        else
+        {
+            ch.len = sasls;
+            ch.data = (u_char *)saslstr;
+
+            ch64.len = ngx_base64_encoded_length(ch.len);
+            ch64.data = ngx_palloc (c->pool, ch64.len);
+
+            if (ch64.data == NULL) {
+                return SASL_FAIL;
+            }
+
+            ngx_encode_base64 (&ch64, &ch);
+        }
+
+        if (rc == SASL_CONTINUE)
+        {
+            /* For IMAP/POP, we need to send "+" SP <challenge> CRLF */
+            if (s->protocol == NGX_MAIL_IMAP_PROTOCOL ||
+                s->protocol == NGX_MAIL_POP3_PROTOCOL
+               )
+            {
+                challenge->len = sizeof("+ ") -1 + ch64.len + sizeof(CRLF) -1;
+                challenge->data = ngx_palloc (c->pool,challenge->len);
+
+                if (challenge->data == NULL) {
+                    return SASL_FAIL;
+                }
+
+                memcpy (challenge->data,"+ ",sizeof("+ ") - 1);
+                memcpy (challenge->data+sizeof("+ ")-1,ch64.data,ch64.len);
+                memcpy (challenge->data+sizeof("+ ")-1+ch64.len,CRLF,
+                        sizeof(CRLF)-1);
+            }
+            else
+            {
+                challenge->data = ch64.data;
+                challenge->len = ch64.len;
+            }
+        }
+        else  /* SASL_OK */
+        {
+            ngx_log_debug0 (NGX_LOG_DEBUG_MAIL, c->log, 0,
+                "SASL auth negotiation complete");
+
+            authc = NULL;
+            authz = NULL;
+
+            sasl_getprop(s->saslconn, SASL_AUTHUSER, (const void **)&authc);
+            sasl_getprop(s->saslconn, SASL_USERNAME, (const void **)&authz);
+
+            ngx_log_debug2 (NGX_LOG_DEBUG_MAIL, c->log, 0,
+                "sasl: authc=%s,authz=%s",
+                authc == NULL ? "null" : authc,
+                authz == NULL ? "null" : authz
+            );
+
+            /*  authc must always be present
+                if authc doesn't end in @realm, then we append the default realm
+                from the config file
+             */
+
+            /* s->login is authz if present, otherwise it is authc
+             */
+
+            if (authc == NULL)
+            {
+                ngx_log_debug0(NGX_LOG_DEBUG_MAIL,c->log,0,
+                    "sasl: cannot get authc, authentication will fail");
+                rc = SASL_BADAUTH;
+            }
+            else
+            {
+                if (strrchr(authc,'@') == NULL) {
+                    needRealm = 1;
+                } else {
+                    needRealm = 0;
+                }
+
+                if ((authz == NULL) || (ngx_strcmp(authc,authz) == 0)) {
+                    inheritAuthZ = 1;
+                } else {
+                    inheritAuthZ = 0;
+                }
+
+                len = ngx_strlen(authc);
+
+                if (needRealm) {
+                    if (cscf->default_realm.len > 0) {
+                        ngx_log_debug1(NGX_LOG_DEBUG_MAIL,c->log,0,
+                            "No realm found in AUTHC, using config default %V", &cscf->default_realm);
+                        len += (1 + cscf->default_realm.len);
+                    } else {
+                        ngx_log_error(NGX_LOG_ERR,c->log, 0,
+                            "SASL realm required, but no realm found in authenticating principal");
+                        ngx_log_error(NGX_LOG_ERR,c->log, 0,
+                            "Authentication will fail. Set the `default_realm' variable to the default kerberos realm");
+                    }
+                }
+
+                s->authid.data = ngx_palloc(c->pool,len);
+                if (s->authid.data == NULL) {
+                    s->authid.data = (u_char *)"";
+                    s->authid.len = 0;
+                    rc = SASL_NOMEM;
+                } else {
+                    s->authid.len = len;
+                    p = s->authid.data;
+                    p = ngx_cpymem (p,authc,strlen(authc));
+
+                    if (needRealm) {
+                        if (cscf->default_realm.len > 0) {
+                            *p++ = '@';
+                            p = ngx_cpymem (p,cscf->default_realm.data,cscf->default_realm.len);
+                        }
+                    }
+                }
+
+                if (inheritAuthZ) {
+                    /* no separate authz was specified, or authz was same as authc
+                       therefore the same changes made to authc must apply to authz
+                     */
+                    s->login.data = ngx_pstrdup(c->pool,&s->authid);
+                    if (s->login.data == NULL) {
+                        s->login.data = (u_char*)"";
+                        s->login.len = 0;
+                        rc = SASL_NOMEM;
+                    } else {
+                        s->login.len = s->authid.len;
+                    }
+                } else {
+                    /* a separate authz was specified */
+                    s->login.len  = ngx_strlen(authz);
+                    s->login.data = ngx_palloc(c->pool,s->login.len);
+                    if (s->login.data == NULL) {
+                        s->login.data = (u_char*)"";
+                        s->login.len = 0;
+                        rc = SASL_NOMEM;
+                    } else {
+                        ngx_memcpy(s->login.data,authz,s->login.len);
+                    }
+                }
+            }
+
+            if(rc == SASL_OK)
+            {
+                ngx_log_debug2(NGX_LOG_DEBUG_MAIL,c->log,0,
+                    "sasl: auth exchange completed, login:%V, authc:%V", 
+                    &s->login, &s->authid);
+            }
+
+            /* we don't need the SASL object after authentication because
+               we don't negotiate a security layer with any ssf 
+             */
+
+            ngx_mail_dispose_sasl_context(s);
+        }
+    }
+
+    return rc;
+}
+
 
 void
 ngx_mail_send(ngx_event_t *wev)
@@ -575,7 +1639,7 @@
         }
 
         if (s->quit) {
-            ngx_mail_close_connection(c);
+            ngx_mail_end_session(s);
             return;
         }
 
@@ -605,6 +1669,82 @@
     }
 }
 
+void
+ngx_mail_do_auth(ngx_mail_session_t *s, ngx_connection_t *c)
+{
+    throttle_callback_t          *callback;
+    ngx_mail_throttle_srv_conf_t *tscf;
+    ngx_mail_zmauth_conf_t   *zmcf;
+
+    zmcf = (ngx_mail_zmauth_conf_t *)ngx_mail_get_module_srv_conf(s, ngx_mail_zmauth_module);
+    if (zmcf->use_zmauth != 1) {
+        ngx_mail_auth(s, c);
+        return;
+    }
+
+    /* all auth mechanisms for all protocols pass through ngx_mail_do_auth()
+       here. Therefore, it is best to just look at the zimbra extensions 
+       *once* at this point, rather than peppering that code all across 
+     */
+
+    if (has_zimbra_extensions(s->login)) {
+        s->zlogin = get_zimbra_extension(s->login);
+        s->login.len -= s->zlogin.len;
+    } else {
+        s->zlogin.data = (u_char *)"";
+        s->zlogin.len = 0;
+    }
+
+    if (s->usedauth)
+    {
+        if (has_zimbra_extensions(s->dusr)) {
+            s->zusr = get_zimbra_extension(s->dusr);
+            s->dusr.len -= s->zusr.len;
+        } else {
+            s->zusr.data = (u_char *)"";
+            s->zusr.len = 0;
+        }
+    }
+
+    if (s->usedauth) {
+        /* technically, zimbra extensions are not allowed in authc
+           but it is too troublesome to reject the login appropriately
+           at this point (with the correct message), therefore it is 
+           less bother to just pass the authc + {wm,ni,tb} to upstream
+         */
+        if (s->login.len == s->dusr.len &&
+            ngx_memcmp(s->login.data, s->dusr.data, s->login.len) == 0) {
+            s->qualifydauth = 1;
+        }
+    }
+
+    callback = ngx_pcalloc(c->pool, sizeof(throttle_callback_t));
+    if (callback == NULL) {
+        ngx_mail_session_internal_server_error(s);
+        return;
+    }
+
+    callback->check_only = 1;    /* just check the counter's value */
+    callback->session = s;
+    callback->connection = c;
+    callback->log = ngx_cycle->log;
+    callback->pool = c->pool;
+    callback->on_allow = ngx_mail_allow_userauth;
+    callback->on_deny = ngx_mail_choke_userauth;
+
+    /* because of DOS attacks against legitimate users, throttling is 
+       postponed till after authentication
+     */
+    tscf = ngx_mail_get_module_srv_conf (s, ngx_mail_throttle_module);
+    if (tscf->mail_login_user_max == 0) {
+        callback->on_allow(callback);
+    } else {
+        ngx_mail_throttle_user(s->login, callback);
+    }
+
+    /* previous body of ngx_mail_do_auth() now in ngx_mail_allow_userauth */
+}
+
 
 ngx_int_t
 ngx_mail_read_command(ngx_mail_session_t *s, ngx_connection_t *c)
@@ -691,20 +1831,71 @@
     ngx_mail_auth_http_init(s);
 }
 
-
+/* send a protocol-suitable internal error message to downstream
+   close the downstream connection immediately afterwards
+ */
 void
 ngx_mail_session_internal_server_error(ngx_mail_session_t *s)
 {
     ngx_mail_core_srv_conf_t  *cscf;
+    ngx_connection_t          *c;
 
     cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);
 
     s->out = cscf->protocol->internal_server_error;
-    s->quit = 1;
-
+    c = s->connection->write->data;
     ngx_mail_send(s->connection->write);
+    if (c->destroyed) {
+        return;
+    }
+    /* clean up */
+    ngx_mail_cleanup_t * cln = s->cleanup;
+    while (cln != NULL) {
+        cln->handler(cln->data);
+        cln = cln->next;
+    }
+
+    ngx_mail_close_connection (s->connection);
 }
 
+/* send a protocol-suitable bye message to downstream
+   close the downstream connection immediately afterwards
+ */
+void
+ngx_mail_end_session(ngx_mail_session_t *s)
+{
+    ngx_str_t            bye = ngx_mail_session_getquitmsg(s);
+    ngx_connection_t    *c = s->connection;
+
+    if (bye.len > 0) {
+        c->send(c, bye.data, bye.len);
+    }
+
+    /* clean up */
+    ngx_mail_cleanup_t * cln = s->cleanup;
+    while (cln != NULL) {
+        cln->handler(cln->data);
+        cln = cln->next;
+    }
+
+    ngx_mail_close_connection (c);
+}
+
+/* return protocol-specific bye message */
+ngx_str_t ngx_mail_session_getquitmsg(ngx_mail_session_t *s)
+{
+    ngx_mail_core_srv_conf_t *cscf;
+    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);
+    return cscf->protocol->quit_msg;
+}
+
+/* return protocol-specific internal error message */
+ngx_str_t ngx_mail_session_geterrmsg(ngx_mail_session_t *s)
+{
+    ngx_mail_core_srv_conf_t  *cscf;
+    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);
+    return cscf->protocol->internal_server_error;
+}
 
 void
 ngx_mail_close_connection(ngx_connection_t *c)
@@ -738,6 +1929,13 @@
     ngx_destroy_pool(pool);
 }
 
+/* note -- we want to log the local and remote host/port information for the 
+   mail proxy sessions. however, nginx allows a mail servers to be specified as
+   listening on a unix domain socket. the code below assumes that the sockaddr
+   structure is pointing to an IPv4 address, and prints the address information
+   accordingly. we will need to modify the code in case we want to support
+   printing of unix domain socket information 
+ */
 
 u_char *
 ngx_mail_log_error(ngx_log_t *log, u_char *buf, size_t len)
@@ -754,7 +1952,11 @@
 
     ctx = log->data;
 
-    p = ngx_snprintf(buf, len, ", client: %V", ctx->client);
+    if (ctx->client_port && ctx->client_port < 65536) {
+        p = ngx_snprintf(buf, len, ", client: %V:%ui", ctx->client, ctx->client_port);
+    } else {
+        p = ngx_snprintf(buf, len, ", client: %V", ctx->client, ctx->client_port);
+    }
     len -= p - buf;
     buf = p;
 
@@ -781,8 +1983,125 @@
     if (s->proxy == NULL) {
         return p;
     }
+    /* with proxy, output the proxy relationship */
+
+    u_char               dw_host[NGX_SOCKADDRLEN],
+                         dw_peer[NGX_SOCKADDRLEN],
+                         up_host[NGX_SOCKADDRLEN],
+                         up_peer[NGX_SOCKADDRLEN];
+
+    socklen_t            dw_host_len, dw_peer_len,
+                         up_host_len, up_peer_len,
+                         n;
+
+    ngx_memzero (dw_peer, NGX_SOCKADDRLEN);
+    ngx_memzero (dw_host, NGX_SOCKADDRLEN);
+    ngx_memzero (up_host, NGX_SOCKADDRLEN);
+    ngx_memzero (up_peer, NGX_SOCKADDRLEN);
+
+    dw_host_len = dw_peer_len = up_host_len = up_peer_len = NGX_SOCKADDRLEN;
+
+    if (s->connection) {
+       getsockname
+            (s->connection->fd, (struct sockaddr *)dw_host, &dw_host_len);
+
+       getpeername
+            (s->connection->fd, (struct sockaddr *)dw_peer, &dw_peer_len);
+    }
+
+    if (s->proxy->upstream.connection) {
+        getsockname (s->proxy->upstream.connection->fd,
+            (struct sockaddr *)up_host, &up_host_len);
+        getpeername (s->proxy->upstream.connection->fd,
+            (struct sockaddr *)up_peer, &up_peer_len);
+    }
 
     p = ngx_snprintf(buf, len, ", upstream: %V", s->proxy->upstream.name);
+    len -= p - buf;
+    buf = p;
+
+    /* generate "(dw_peer->dw_host) <=> (up_host->up_peer)" */
+    p = ngx_snprintf(buf, len, " (");
+    len -= p - buf;
+    buf = p;
+
+    n = ngx_sock_ntop((struct sockaddr *)dw_peer, dw_peer_len, buf, len, 1);
+    len -= n;
+    buf += n;
+
+    *buf++ = '-';
+    len--;
+    *buf++ = '>';
+    len--;
+
+    n = ngx_sock_ntop((struct sockaddr *)dw_host, dw_host_len, buf, len, 1);
+    len -= n;
+    buf += n;
+
+    p = ngx_snprintf(buf, len, ") <=> (");
+    len -= p - buf;
+    buf = p;
+
+    n = ngx_sock_ntop((struct sockaddr *)up_host, up_host_len, buf, len, 1);
+    len -= n;
+    buf += n;
+
+    *buf++ = '-';
+    len--;
+    *buf++ = '>';
+    len--;
+
+    n = ngx_sock_ntop((struct sockaddr *)up_peer, up_peer_len, buf, len, 1);
+    len -= n;
+    buf += n;
+
+    *buf++ = ')';
+    len--;
+
+    p = buf;
 
     return p;
 }
+
+/*
+ * Giving a socket, return its local addr string representation IP. The
+ * string will be allocated on "pool".
+ */
+ngx_str_t ngx_mail_get_socket_local_addr_str (ngx_pool_t *pool, ngx_socket_t s)
+{
+    int family;
+    static ngx_str_t     res;
+    struct sockaddr_in  *sin;
+#if (NGX_HAVE_INET6)
+    struct sockaddr_in6 *sin6;
+#endif
+    u_char              *p;
+    socklen_t            len, strlen;
+    u_char               sockaddr[NGX_SOCKADDRLEN];
+
+    len = NGX_SOCKADDRLEN;
+    ngx_memzero(sockaddr, len);
+    getsockname(s, (struct sockaddr*)sockaddr, &len);
+
+    family = ((struct sockaddr *)sockaddr)->sa_family;
+    if (family == AF_INET) {
+        sin = (struct sockaddr_in *)sockaddr;
+        p = ngx_palloc(pool, NGX_INET_ADDRSTRLEN);
+        strlen = ngx_inet_ntop (family, &(sin->sin_addr.s_addr), p,
+                NGX_INET_ADDRSTRLEN);
+
+#if (NGX_HAVE_INET6)
+    } else {
+        sin6 = (struct sockaddr_in6 *)sockaddr;
+        p = ngx_palloc(pool, NGX_INET6_ADDRSTRLEN);
+        strlen = ngx_inet_ntop (family, &(sin6->sin6_addr.s6_addr),
+                p, NGX_INET6_ADDRSTRLEN);
+#endif
+
+    }
+
+    res.data = p;
+    res.len = strlen;
+
+    return res;
+}
diff -ur nginx-1.7.1/src/mail/ngx_mail_imap_handler.c nginx-1.7.1-zimbra/src/mail/ngx_mail_imap_handler.c
--- nginx-1.7.1/src/mail/ngx_mail_imap_handler.c	2014-05-27 06:58:10.000000000 -0700
+++ nginx-1.7.1-zimbra/src/mail/ngx_mail_imap_handler.c	2014-07-23 12:24:10.000000000 -0700
@@ -4,6 +4,10 @@
  * Copyright (C) Nginx, Inc.
  */
 
+/*
+ * Portions Copyright (c) Zimbra Software, LLC. [1998-2011]. All Rights Reserved.
+ */
+
 
 #include <ngx_config.h>
 #include <ngx_core.h>
@@ -20,27 +24,35 @@
     ngx_connection_t *c);
 static ngx_int_t ngx_mail_imap_starttls(ngx_mail_session_t *s,
     ngx_connection_t *c);
+static ngx_int_t ngx_mail_imap_id(ngx_mail_session_t *s,
+    ngx_connection_t *c);
 
 
-static u_char  imap_greeting[] = "* OK IMAP4 ready" CRLF;
-static u_char  imap_star[] = "* ";
+/*static u_char  imap_greeting[] = "* OK IMAP4 ready" CRLF; zimbra uses the greeting specified by the directive */
+static u_char  imap_star[] = "*";
 static u_char  imap_ok[] = "OK completed" CRLF;
-static u_char  imap_next[] = "+ OK" CRLF;
+static u_char  imap_next[] = "+ " CRLF;
 static u_char  imap_plain_next[] = "+ " CRLF;
+static u_char  imap_gssapi_next[] = "+ " CRLF;
 static u_char  imap_username[] = "+ VXNlcm5hbWU6" CRLF;
 static u_char  imap_password[] = "+ UGFzc3dvcmQ6" CRLF;
-static u_char  imap_bye[] = "* BYE" CRLF;
+static u_char  imap_bye[] = "* BYE Zimbra IMAP server terminating connection" CRLF;
 static u_char  imap_invalid_command[] = "BAD invalid command" CRLF;
-
+static u_char  imap_unsupported_mech[] = "NO mechanism not supported" CRLF;
+static u_char  imap_nocleartext[] = "NO cleartext logins disabled" CRLF;
+static u_char  imap_authaborted[] = "BAD AUTHENTICATE aborted" CRLF;
+static u_char  imap_login_failed[] = "NO LOGIN failed" CRLF;
+static u_char  imap_authenticate_failed[] = "NO AUTHENTICATE failed" CRLF;
 
 void
 ngx_mail_imap_init_session(ngx_mail_session_t *s, ngx_connection_t *c)
 {
     ngx_mail_core_srv_conf_t  *cscf;
-
+    ngx_mail_imap_srv_conf_t  *iscf;
     cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);
+    iscf = ngx_mail_get_module_srv_conf(s, ngx_mail_imap_module);
 
-    ngx_str_set(&s->out, imap_greeting);
+    s->out = iscf->greeting;
 
     c->read->handler = ngx_mail_imap_init_protocol;
 
@@ -91,6 +103,7 @@
         }
     }
 
+    ngx_mail_set_imap_parse_state_start(s);
     s->mail_state = ngx_imap_start;
     c->read->handler = ngx_mail_imap_auth_state;
 
@@ -116,7 +129,7 @@
     if (rev->timedout) {
         ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, "client timed out");
         c->timedout = 1;
-        ngx_mail_close_connection(c);
+        ngx_mail_end_session(s);    /* send IMAP BYE on timeout */
         return;
     }
 
@@ -134,11 +147,13 @@
         return;
     }
 
-    tag = 1;
-    s->text.len = 0;
-    ngx_str_set(&s->out, imap_ok);
-
-    if (rc == NGX_OK) {
+    if (rc == NGX_IMAP_NEXT) {
+        tag = 0;
+        ngx_str_set(&s->out, imap_next);
+    } else {
+        tag = 1;
+        ngx_str_set(&s->out, imap_ok);
+        s->text.len = 0;
 
         ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0, "imap auth command: %i",
                        s->command);
@@ -164,95 +179,171 @@
             s->backslash = 0;
         }
 
-        switch (s->mail_state) {
+        if (rc == NGX_OK) {
+            switch (s->mail_state) {
 
-        case ngx_imap_start:
+            case ngx_imap_start:
 
-            switch (s->command) {
+                switch (s->command) {
 
-            case NGX_IMAP_LOGIN:
-                rc = ngx_mail_imap_login(s, c);
-                break;
+                case NGX_IMAP_LOGIN:
+                      rc = ngx_mail_imap_login(s, c);
+                      break;
 
-            case NGX_IMAP_AUTHENTICATE:
-                rc = ngx_mail_imap_authenticate(s, c);
-                tag = (rc != NGX_OK);
-                break;
+                case NGX_IMAP_AUTHENTICATE:
+                      rc = ngx_mail_imap_authenticate(s, c);
+                      break;
 
-            case NGX_IMAP_CAPABILITY:
-                rc = ngx_mail_imap_capability(s, c);
-                break;
+                case NGX_IMAP_CAPABILITY:
+                      rc = ngx_mail_imap_capability(s, c);
+                      break;
 
-            case NGX_IMAP_LOGOUT:
-                s->quit = 1;
-                ngx_str_set(&s->text, imap_bye);
-                break;
+                case NGX_IMAP_LOGOUT:
+                    s->quit = 1;
+                    ngx_str_set(&s->text, imap_bye);
+                    break;
 
-            case NGX_IMAP_NOOP:
-                break;
+                case NGX_IMAP_NOOP:
+                    break;
 
-            case NGX_IMAP_STARTTLS:
-                rc = ngx_mail_imap_starttls(s, c);
-                break;
+                case NGX_IMAP_STARTTLS:
+                    rc = ngx_mail_imap_starttls(s, c);
+                    break;
 
-            default:
-                rc = NGX_MAIL_PARSE_INVALID_COMMAND;
-                break;
-            }
+                case NGX_IMAP_ID:
+                    rc = ngx_mail_imap_id(s, c);
+                    break;
 
-            break;
+                default:
+                    rc = NGX_MAIL_PARSE_INVALID_COMMAND;
+                    break;
+                }
 
-        case ngx_imap_auth_login_username:
-            rc = ngx_mail_auth_login_username(s, c, 0);
+                break;
 
-            tag = 0;
-            ngx_str_set(&s->out, imap_password);
-            s->mail_state = ngx_imap_auth_login_password;
+            case ngx_imap_auth_login_username:
+                rc = ngx_mail_auth_login_username(s, c, 0);
+                if (rc == NGX_MAIL_AUTH_ARGUMENT) {
+                    ngx_str_set(&s->out, imap_password);
+                    s->mail_state = ngx_imap_auth_login_password;
+                }
+
+                break;
 
-            break;
+            case ngx_imap_auth_login_password:
+                rc = ngx_mail_auth_login_password(s, c);
+                break;
 
-        case ngx_imap_auth_login_password:
-            rc = ngx_mail_auth_login_password(s, c);
-            break;
+            case ngx_imap_auth_plain:
+                rc = ngx_mail_auth_plain(s, c, 0);
+                break;
 
-        case ngx_imap_auth_plain:
-            rc = ngx_mail_auth_plain(s, c, 0);
-            break;
+            case ngx_imap_auth_gssapi:
+                {
+                    ngx_str_t output;
+                    ngx_str_set(&output, "");
+                    rc = ngx_mail_auth_gssapi(s, c, &output);
+                    if (rc == NGX_MAIL_AUTH_ARGUMENT) {
+                        s->mail_state = ngx_imap_auth_gssapi;
+                        s->out = output;
+                    }
+                    break;
+                }
 
-        case ngx_imap_auth_cram_md5:
-            rc = ngx_mail_auth_cram_md5(s, c);
-            break;
+            case ngx_imap_auth_cram_md5:
+                rc = ngx_mail_auth_cram_md5(s, c);
+                break;
+            }
         }
-
-    } else if (rc == NGX_IMAP_NEXT) {
-        tag = 0;
-        ngx_str_set(&s->out, imap_next);
     }
 
     switch (rc) {
 
     case NGX_DONE:
-        ngx_mail_auth(s, c);
+        ngx_mail_do_auth(s, c);
         return;
 
+    case NGX_OK:
+        ngx_mail_set_imap_parse_state_start(s);
+        s->arg_start = NULL;
+        ngx_mail_reset_parse_buffer(s);
+        break;
+
+    case NGX_MAIL_AUTH_ABORT:
+        ngx_str_set(&s->out, imap_authaborted);
+        s->mail_state = ngx_imap_start;
+        ngx_mail_set_imap_parse_state_start(s);
+        s->arg_start = NULL;
+        ngx_mail_reset_parse_buffer(s);
+        break;
+
     case NGX_ERROR:
         ngx_mail_session_internal_server_error(s);
         return;
+    case NGX_MAIL_AUTH_FAILED:
+        ngx_str_set(&s->out, imap_authenticate_failed);
+        s->mail_state = ngx_imap_start;
+        ngx_mail_set_imap_parse_state_start(s);
+        s->arg_start = NULL;
+        ngx_mail_reset_parse_buffer(s);
+        break;
+
+    case NGX_MAIL_LOGIN_FAILED:
+        ngx_str_set(&s->out, imap_login_failed);
+        s->mail_state = ngx_imap_start;
+        ngx_mail_set_imap_parse_state_start(s);
+        s->arg_start = NULL;
+        ngx_mail_reset_parse_buffer(s);
+        break;
+
+    case NGX_MAIL_PARSE_INVALID_AUTH_MECH:
+        ngx_log_debug0 (NGX_LOG_DEBUG_MAIL, c->log, 0,
+            "unsupported IMAP auth mechanism");
+        ngx_str_set(&s->out, imap_unsupported_mech);
+        s->mail_state = ngx_imap_start;
+        ngx_mail_set_imap_parse_state_start(s);
+        s->arg_start = NULL;
+        ngx_mail_reset_parse_buffer(s);
+        break;
 
     case NGX_MAIL_PARSE_INVALID_COMMAND:
-        s->state = 0;
         ngx_str_set(&s->out, imap_invalid_command);
         s->mail_state = ngx_imap_start;
+        ngx_mail_set_imap_parse_state_start(s);
+        s->arg_start = NULL;
+        ngx_mail_reset_parse_buffer(s);
+        break;
+
+    case NGX_MAIL_AUTH_ARGUMENT:
+        ngx_mail_set_imap_parse_state_argument(s);
+        /* preserve tag, since tag's memory is allocated in buffer, need to set the
+         * buffer pos after tag */
+        s->arg_start = s->buffer->start + s->tag.len;
+        s->buffer->pos = s->arg_start;
+        s->buffer->last = s->arg_start;
+        tag = 0; // just output s->out
+        break;
+
+    case NGX_IMAP_NEXT:
+        /* do nothing, preserve all the state, including s->state, s->mail_state,
+         * , s->buffer, s->arg_start
+         */
         break;
     }
 
-    if (tag) {
+    //clear args
+    if(rc != NGX_IMAP_NEXT) {
+        s->args.nelts = 0;
+    }
+
+    // process the output
+    if (tag) { //text tag out --> out
         if (s->tag.len == 0) {
             ngx_str_set(&s->tag, imap_star);
         }
 
-        if (s->tagged_line.len < s->tag.len + s->text.len + s->out.len) {
-            s->tagged_line.len = s->tag.len + s->text.len + s->out.len;
+        if (s->tagged_line.len < s->tag.len + s->text.len + s->out.len + 1) {
+            s->tagged_line.len = s->tag.len + s->text.len + s->out.len + 1;
             s->tagged_line.data = ngx_pnalloc(c->pool, s->tagged_line.len);
             if (s->tagged_line.data == NULL) {
                 ngx_mail_close_connection(c);
@@ -267,28 +358,13 @@
         }
 
         p = ngx_cpymem(p, s->tag.data, s->tag.len);
+        *p++ = ' '; /* the space between tag and out */
         ngx_memcpy(p, s->out.data, s->out.len);
 
-        s->out.len = s->text.len + s->tag.len + s->out.len;
+        s->out.len = s->text.len + s->tag.len + 1 /*for space*/+ s->out.len;
         s->out.data = s->tagged_line.data;
     }
 
-    if (rc != NGX_IMAP_NEXT) {
-        s->args.nelts = 0;
-
-        if (s->state) {
-            /* preserve tag */
-            s->arg_start = s->buffer->start + s->tag.len;
-            s->buffer->pos = s->arg_start;
-            s->buffer->last = s->arg_start;
-
-        } else {
-            s->buffer->pos = s->buffer->start;
-            s->buffer->last = s->buffer->start;
-            s->tag.len = 0;
-        }
-    }
-
     ngx_mail_send(c->write);
 }
 
@@ -300,6 +376,7 @@
 
 #if (NGX_MAIL_SSL)
     if (ngx_mail_starttls_only(s, c)) {
+        ngx_str_set(&s->text, imap_nocleartext);
         return NGX_MAIL_PARSE_INVALID_COMMAND;
     }
 #endif
@@ -310,6 +387,9 @@
         return NGX_MAIL_PARSE_INVALID_COMMAND;
     }
 
+    if (arg[0].len > NGX_MAIL_MAX_LOGIN_LEN) {
+        return NGX_MAIL_LOGIN_FAILED;
+    }
     s->login.len = arg[0].len;
     s->login.data = ngx_pnalloc(c->pool, s->login.len);
     if (s->login.data == NULL) {
@@ -318,6 +398,9 @@
 
     ngx_memcpy(s->login.data, arg[0].data, s->login.len);
 
+    if (arg[1].len > NGX_MAIL_MAX_PASSWORD_LEN) {
+        return NGX_MAIL_LOGIN_FAILED;
+    }
     s->passwd.len = arg[1].len;
     s->passwd.data = ngx_pnalloc(c->pool, s->passwd.len);
     if (s->passwd.data == NULL) {
@@ -335,6 +418,8 @@
                    "imap login:\"%V\"", &s->login);
 #endif
 
+    s->auth_method = NGX_MAIL_AUTH_PASSWD;
+    s->usedauth = 0;
     return NGX_DONE;
 }
 
@@ -342,47 +427,80 @@
 static ngx_int_t
 ngx_mail_imap_authenticate(ngx_mail_session_t *s, ngx_connection_t *c)
 {
-    ngx_int_t                  rc;
+    ngx_int_t                  rc, res;
     ngx_mail_core_srv_conf_t  *cscf;
     ngx_mail_imap_srv_conf_t  *iscf;
 
-#if (NGX_MAIL_SSL)
-    if (ngx_mail_starttls_only(s, c)) {
-        return NGX_MAIL_PARSE_INVALID_COMMAND;
-    }
-#endif
-
     rc = ngx_mail_auth_parse(s, c);
+    iscf = ngx_mail_get_module_srv_conf(s, ngx_mail_imap_module);
 
     switch (rc) {
 
     case NGX_MAIL_AUTH_LOGIN:
-
+        if (!(iscf->auth_methods & NGX_MAIL_AUTH_LOGIN_ENABLED)) {
+            return NGX_MAIL_PARSE_INVALID_AUTH_MECH;
+        }
         ngx_str_set(&s->out, imap_username);
         s->mail_state = ngx_imap_auth_login_username;
 
-        return NGX_OK;
+        return NGX_MAIL_AUTH_ARGUMENT;
 
     case NGX_MAIL_AUTH_LOGIN_USERNAME:
+        if (!(iscf->auth_methods & NGX_MAIL_AUTH_LOGIN_ENABLED)) {
+            return NGX_MAIL_PARSE_INVALID_AUTH_MECH;
+        }
 
-        ngx_str_set(&s->out, imap_password);
-        s->mail_state = ngx_imap_auth_login_password;
-
-        return ngx_mail_auth_login_username(s, c, 1);
+        res = ngx_mail_auth_login_username(s, c, 1);
+        if (res == NGX_MAIL_AUTH_ARGUMENT) {
+            ngx_str_set(&s->out, imap_password);
+            s->mail_state = ngx_imap_auth_login_password;
+            return NGX_MAIL_AUTH_ARGUMENT;
+        } else {
+            return res;
+        }
 
     case NGX_MAIL_AUTH_PLAIN:
-
+        if (!(iscf->auth_methods & NGX_MAIL_AUTH_PLAIN_ENABLED)) {
+            return NGX_MAIL_PARSE_INVALID_AUTH_MECH;
+        }
         ngx_str_set(&s->out, imap_plain_next);
         s->mail_state = ngx_imap_auth_plain;
 
-        return NGX_OK;
+        return NGX_MAIL_AUTH_ARGUMENT;
 
-    case NGX_MAIL_AUTH_CRAM_MD5:
-
-        iscf = ngx_mail_get_module_srv_conf(s, ngx_mail_imap_module);
+    case NGX_MAIL_AUTH_PLAIN_IR:
+        if (!(iscf->auth_methods & NGX_MAIL_AUTH_PLAIN_ENABLED)) {
+            return NGX_MAIL_PARSE_INVALID_AUTH_MECH;
+        }
+        return ngx_mail_auth_plain(s, c, 1);
+
+    case NGX_MAIL_AUTH_GSSAPI:
+        if (!(iscf->auth_methods & NGX_MAIL_AUTH_GSSAPI_ENABLED)) {
+            return NGX_MAIL_PARSE_INVALID_AUTH_MECH;
+        }
+        ngx_str_set(&s->out, imap_gssapi_next);
+        s->mail_state = ngx_imap_auth_gssapi;
+
+        return NGX_MAIL_AUTH_ARGUMENT;
+
+    case NGX_MAIL_AUTH_GSSAPI_IR:
+        if (!(iscf->auth_methods & NGX_MAIL_AUTH_GSSAPI_ENABLED)) {
+            return NGX_MAIL_PARSE_INVALID_AUTH_MECH;
+        }
+        s->mail_state = ngx_imap_auth_gssapi;
+        ngx_str_t output;
+        ngx_str_set(&output, "");
+        res = ngx_mail_auth_gssapi(s, c, &output);
+        if(res == NGX_MAIL_AUTH_ARGUMENT) {
+            s->out = output;
+            return NGX_MAIL_AUTH_ARGUMENT;
+        } else {
+            return res;
+        }
 
+    case NGX_MAIL_AUTH_CRAM_MD5:
         if (!(iscf->auth_methods & NGX_MAIL_AUTH_CRAM_MD5_ENABLED)) {
-            return NGX_MAIL_PARSE_INVALID_COMMAND;
+            return NGX_MAIL_PARSE_INVALID_AUTH_MECH;
         }
 
         if (s->salt.data == NULL) {
@@ -395,7 +513,7 @@
 
         if (ngx_mail_auth_cram_md5_salt(s, c, "+ ", 2) == NGX_OK) {
             s->mail_state = ngx_imap_auth_cram_md5;
-            return NGX_OK;
+            return NGX_MAIL_AUTH_ARGUMENT;
         }
 
         return NGX_ERROR;
@@ -455,3 +573,66 @@
 
     return NGX_MAIL_PARSE_INVALID_COMMAND;
 }
+
+static ngx_int_t
+ngx_mail_imap_id(ngx_mail_session_t *s, ngx_connection_t * c)
+{
+    size_t i;
+    ngx_mail_imap_srv_conf_t  *iscf;
+    ngx_str_t                 *key, * value;
+
+    iscf = ngx_mail_get_module_srv_conf(s, ngx_mail_imap_module);
+    ngx_log_debug1 (NGX_LOG_DEBUG_MAIL,s->connection->log,0,
+      "imap id received %d parameters from client", s->args.nelts);
+    if (s->args.nelts) {
+      ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+          "client ID params [%d pair(s)]",
+          s->args.nelts/2);
+        for (i = 0; i < s->args.nelts / 2; ++i) {
+            ngx_log_debug3 (NGX_LOG_DEBUG_MAIL,
+                  s->connection->log, 0,
+                  "[pair %d] field:'%V' value:'%V'",
+                  i+1,
+                  (ngx_str_t*)s->args.elts + 2 * i,
+                  (ngx_str_t*)s->args.elts + 2 * i + 1
+                );
+            key = (ngx_str_t*)s->args.elts + 2 * i;
+            /* bug 64978, add support to "name" and "version" field */
+            if (key->len == sizeof ("name") - 1 &&
+                (key->data[0] == 'N' || key->data[0] == 'n') &&
+                (key->data[1] == 'A' || key->data[1] == 'a') &&
+                (key->data[2] == 'M' || key->data[2] == 'm') &&
+                (key->data[3] == 'E' || key->data[3] == 'e')) {
+                value = (ngx_str_t*)s->args.elts + 2 * i + 1;
+
+                s->id_name.data = ngx_pnalloc(c->pool, value->len);
+                if (s->id_name.data == NULL) {
+                    return NGX_ERROR;
+                }
+
+                ngx_memcpy(s->id_name.data, value->data, value->len);
+                s->id_name.len = value->len;
+            } else if (key->len == sizeof ("version") - 1 &&
+                    (key->data[0] == 'V' || key->data[0] == 'v') &&
+                    (key->data[1] == 'E' || key->data[1] == 'e') &&
+                    (key->data[2] == 'R' || key->data[2] == 'r') &&
+                    (key->data[3] == 'S' || key->data[3] == 's') &&
+                    (key->data[4] == 'I' || key->data[4] == 'i') &&
+                    (key->data[5] == 'O' || key->data[5] == 'o') &&
+                    (key->data[6] == 'N' || key->data[6] == 'n')) {
+                value = (ngx_str_t*)s->args.elts + 2 * i + 1;
+
+                s->id_version.data = ngx_pnalloc(c->pool, value->len);
+                if (s->id_version.data == NULL) {
+                    return NGX_ERROR;
+                }
+
+                ngx_memcpy(s->id_version.data, value->data, value->len);
+                s->id_version.len = value->len;
+            }
+        }
+    }
+    s->text = iscf->id;
+
+    return NGX_OK;
+}
diff -ur nginx-1.7.1/src/mail/ngx_mail_imap_module.c nginx-1.7.1-zimbra/src/mail/ngx_mail_imap_module.c
--- nginx-1.7.1/src/mail/ngx_mail_imap_module.c	2014-05-27 06:58:10.000000000 -0700
+++ nginx-1.7.1-zimbra/src/mail/ngx_mail_imap_module.c	2014-07-23 12:24:10.000000000 -0700
@@ -4,6 +4,10 @@
  * Copyright (C) Nginx, Inc.
  */
 
+/*
+ * Portions Copyright (c) Zimbra Software, LLC. [1998-2011]. All Rights Reserved.
+ */
+
 
 #include <ngx_config.h>
 #include <ngx_core.h>
@@ -15,7 +19,9 @@
 static void *ngx_mail_imap_create_srv_conf(ngx_conf_t *cf);
 static char *ngx_mail_imap_merge_srv_conf(ngx_conf_t *cf, void *parent,
     void *child);
+static char *ngx_mail_imap_id (ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
 
+static ngx_str_t default_imap_greeting = ngx_string("* OK IMAP4 ready");
 
 static ngx_str_t  ngx_mail_imap_default_capabilities[] = {
     ngx_string("IMAP4"),
@@ -25,21 +31,23 @@
 };
 
 
-static ngx_conf_bitmask_t  ngx_mail_imap_auth_methods[] = {
+static ngx_conf_bitmask_t ngx_mail_imap_auth_methods[] = {
     { ngx_string("plain"), NGX_MAIL_AUTH_PLAIN_ENABLED },
     { ngx_string("login"), NGX_MAIL_AUTH_LOGIN_ENABLED },
     { ngx_string("cram-md5"), NGX_MAIL_AUTH_CRAM_MD5_ENABLED },
+    { ngx_string("gssapi"), NGX_MAIL_AUTH_GSSAPI_ENABLED },
     { ngx_null_string, 0 }
 };
 
-
+/* zimbra's merge_conf method doesn't use this
 static ngx_str_t  ngx_mail_imap_auth_methods_names[] = {
     ngx_string("AUTH=PLAIN"),
     ngx_string("AUTH=LOGIN"),
-    ngx_null_string,  /* APOP */
+    ngx_null_string,  // APOP
     ngx_string("AUTH=CRAM-MD5"),
-    ngx_null_string   /* NONE */
-};
+    ngx_string("AUTH=GSSAPI"),
+    ngx_null_string   * NONE *
+}; */
 
 
 static ngx_mail_protocol_t  ngx_mail_imap_protocol = {
@@ -52,7 +60,8 @@
     ngx_mail_imap_parse_command,
     ngx_mail_imap_auth_state,
 
-    ngx_string("* BAD internal server error" CRLF)
+    ngx_string("* BAD internal server error" CRLF),
+    ngx_string("* BYE Zimbra IMAP server terminating connection" CRLF)
 };
 
 
@@ -72,6 +81,13 @@
       offsetof(ngx_mail_imap_srv_conf_t, capabilities),
       NULL },
 
+    { ngx_string("imap_id"),
+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_1MORE,
+      ngx_mail_imap_id,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_imap_srv_conf_t, id_params),
+      NULL },
+
     { ngx_string("imap_auth"),
       NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_1MORE,
       ngx_conf_set_bitmask_slot,
@@ -79,6 +95,20 @@
       offsetof(ngx_mail_imap_srv_conf_t, auth_methods),
       &ngx_mail_imap_auth_methods },
 
+    { ngx_string("imap_literalauth"),
+      NGX_MAIL_MAIN_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_flag_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_imap_srv_conf_t, literalauth),
+      NULL },
+
+    { ngx_string("imap_greeting"),
+      NGX_MAIL_MAIN_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_imap_srv_conf_t, greeting),
+      NULL },
+
       ngx_null_command
 };
 
@@ -128,6 +158,17 @@
         return NULL;
     }
 
+    if (ngx_array_init(&iscf->id_params, cf->pool, 4, sizeof(ngx_str_t))
+    	!= NGX_OK)
+    {
+    	return NULL;
+    }
+
+    iscf->literalauth = NGX_CONF_UNSET;
+
+    ngx_str_null(&iscf->ua_name);
+    ngx_str_null(&iscf->ua_version);
+
     return iscf;
 }
 
@@ -138,14 +179,14 @@
     ngx_mail_imap_srv_conf_t *prev = parent;
     ngx_mail_imap_srv_conf_t *conf = child;
 
-    u_char      *p, *auth;
-    size_t       size;
+    u_char      *p, *p1, *p2, *p3;
+    size_t      size, s1, s2, s3;
     ngx_str_t   *c, *d;
-    ngx_uint_t   i, m;
+    ngx_uint_t   i;
 
     ngx_conf_merge_size_value(conf->client_buffer_size,
                               prev->client_buffer_size,
-                              (size_t) ngx_pagesize);
+                              (size_t) 4 * ngx_pagesize);
 
     ngx_conf_merge_bitmask_value(conf->auth_methods,
                               prev->auth_methods,
@@ -153,6 +194,10 @@
                                |NGX_MAIL_AUTH_PLAIN_ENABLED));
 
 
+    if (conf->id_params.nelts == 0) {
+        conf->id_params = prev->id_params;
+    }
+    
     if (conf->capabilities.nelts == 0) {
         conf->capabilities = prev->capabilities;
     }
@@ -169,85 +214,244 @@
         }
     }
 
-    size = sizeof("* CAPABILITY" CRLF) - 1;
+    s1 = sizeof("* CAPABILITY" CRLF) - 1;
+    s2 = s1;
+    s3 = s1;
 
     c = conf->capabilities.elts;
     for (i = 0; i < conf->capabilities.nelts; i++) {
-        size += 1 + c[i].len;
+        s1 += 1 + c[i].len;
+        s2 += 1 + c[i].len;
+        s3 += 1 + c[i].len;
     }
 
-    for (m = NGX_MAIL_AUTH_PLAIN_ENABLED, i = 0;
-         m <= NGX_MAIL_AUTH_CRAM_MD5_ENABLED;
-         m <<= 1, i++)
-    {
-        if (m & conf->auth_methods) {
-            size += 1 + ngx_mail_imap_auth_methods_names[i].len;
-        }
+    if (conf->auth_methods & NGX_MAIL_AUTH_LOGIN_ENABLED) {
+        s1 += sizeof (" AUTH=LOGIN") - 1;
+        s2 += sizeof (" AUTH=LOGIN") - 1;
+    }
+    if (conf->auth_methods & NGX_MAIL_AUTH_PLAIN_ENABLED) {
+        s1 += sizeof (" AUTH=PLAIN") - 1;
+        s2 += sizeof (" AUTH=PLAIN") - 1;
+    }
+    if (conf->auth_methods & NGX_MAIL_AUTH_CRAM_MD5_ENABLED) {
+        s1 += sizeof (" AUTH=CRAM-MD5") - 1;
+        s2 += sizeof (" AUTH=CRAM-MD5") - 1;
+    }
+    if (conf->auth_methods & NGX_MAIL_AUTH_GSSAPI_ENABLED) {
+        s1 += sizeof (" AUTH=GSSAPI") - 1;
+        s2 += sizeof (" AUTH=GSSAPI") - 1;
+        s3 += sizeof (" AUTH=GSSAPI") - 1;
     }
 
-    p = ngx_pnalloc(cf->pool, size);
-    if (p == NULL) {
+    s2 += sizeof (" STARTTLS") - 1;
+    s3 += sizeof (" STARTTLS") - 1;
+    s3 += sizeof (" LOGINDISABLED") - 1;
+
+    p1 = ngx_palloc(cf->pool, s1);
+    if (p1 == NULL) {
+        return NGX_CONF_ERROR;
+    }
+    p2 = ngx_palloc(cf->pool, s2);
+    if (p2 == NULL) {
+        return NGX_CONF_ERROR;
+    }
+    p3 = ngx_palloc(cf->pool, s3);
+    if (p3 == NULL) {
         return NGX_CONF_ERROR;
     }
 
-    conf->capability.len = size;
-    conf->capability.data = p;
+    conf->capability.len = s1;
+    conf->capability.data = p1;
 
-    p = ngx_cpymem(p, "* CAPABILITY", sizeof("* CAPABILITY") - 1);
+    conf->starttls_capability.len = s2;
+    conf->starttls_capability.data = p2;
 
-    for (i = 0; i < conf->capabilities.nelts; i++) {
-        *p++ = ' ';
-        p = ngx_cpymem(p, c[i].data, c[i].len);
-    }
+    conf->starttls_only_capability.len = s3;
+    conf->starttls_only_capability.data = p3;
 
-    auth = p;
+    p1 = ngx_cpymem(p1, "* CAPABILITY", sizeof("* CAPABILITY") - 1);
+    p2 = ngx_cpymem(p2, "* CAPABILITY", sizeof("* CAPABILITY") - 1);
+    p3 = ngx_cpymem(p3, "* CAPABILITY", sizeof("* CAPABILITY") - 1);
 
-    for (m = NGX_MAIL_AUTH_PLAIN_ENABLED, i = 0;
-         m <= NGX_MAIL_AUTH_CRAM_MD5_ENABLED;
-         m <<= 1, i++)
-    {
-        if (m & conf->auth_methods) {
-            *p++ = ' ';
-            p = ngx_cpymem(p, ngx_mail_imap_auth_methods_names[i].data,
-                           ngx_mail_imap_auth_methods_names[i].len);
-        }
+    c = conf->capabilities.elts;
+    for (i = 0; i < conf->capabilities.nelts; i++) {
+        *p1++ = ' ';
+        p1 = ngx_cpymem(p1,c[i].data,c[i].len);
+        *p2++ = ' ';
+        p2 = ngx_cpymem(p2,c[i].data,c[i].len);
+        *p3++ = ' ';
+        p3 = ngx_cpymem(p3,c[i].data,c[i].len);
+    }
+
+    if (conf->auth_methods & NGX_MAIL_AUTH_LOGIN_ENABLED) {
+        p1 = ngx_cpymem(p1," AUTH=LOGIN", sizeof(" AUTH=LOGIN") - 1);
+        p2 = ngx_cpymem(p2," AUTH=LOGIN", sizeof(" AUTH=LOGIN") - 1);
+    }
+    if (conf->auth_methods & NGX_MAIL_AUTH_PLAIN_ENABLED) {
+        p1 = ngx_cpymem(p1," AUTH=PLAIN", sizeof(" AUTH=PLAIN") - 1);
+        p2 = ngx_cpymem(p2," AUTH=PLAIN", sizeof(" AUTH=PLAIN") - 1);
+    }
+    if (conf->auth_methods & NGX_MAIL_AUTH_CRAM_MD5_ENABLED) {
+        p1 = ngx_cpymem(p1," AUTH=CRAM-MD5", sizeof(" AUTH=CRAM-MD5") - 1);
+        p2 = ngx_cpymem(p2," AUTH=CRAM-MD5", sizeof(" AUTH=CRAM-MD5") - 1);
+    }
+    if (conf->auth_methods & NGX_MAIL_AUTH_GSSAPI_ENABLED) {
+        p1 = ngx_cpymem(p1," AUTH=GSSAPI", sizeof(" AUTH=GSSAPI") - 1);
+        p2 = ngx_cpymem(p2," AUTH=GSSAPI", sizeof(" AUTH=GSSAPI") - 1);
+        p3 = ngx_cpymem(p3," AUTH=GSSAPI", sizeof(" AUTH=GSSAPI") - 1);
+    }
+
+    p2 = ngx_cpymem(p2," STARTTLS",sizeof(" STARTTLS")-1);
+    p3 = ngx_cpymem(p3," STARTTLS",sizeof(" STARTTLS")-1);
+    p3 = ngx_cpymem(p3," LOGINDISABLED",sizeof(" LOGINDISABLED")-1);
+
+    *p1++ = CR; *p1++ = LF;
+    *p2++ = CR; *p2++ = LF;
+    *p3++ = CR; *p3++ = LF;
+
+     ngx_conf_merge_str_value(conf->greeting, prev->greeting, "");
+     if (conf->greeting.len == 0) {
+        conf->greeting = default_imap_greeting;
+     }
+
+    p = ngx_pnalloc(cf->pool, conf->greeting.len + 2);
+    if (p == NULL) {
+        return NGX_CONF_ERROR;
     }
 
-    *p++ = CR; *p = LF;
+     ngx_memcpy(p, conf->greeting.data, conf->greeting.len);
+     ngx_memcpy(p + conf->greeting.len, CRLF, sizeof(CRLF)-1);
+     conf->greeting.data = p;
+     conf->greeting.len += 2;
+     
+    size = sizeof ("* ID ()" CRLF) - 1;
+
+    c = conf->id_params.elts;
+    for (i = 0; i < conf->id_params.nelts; ++i) {
+        if (!((c[i].len == 3) &&
+            (c[i].data[0] == 'n' || c[i].data[0] == 'N') &&
+            (c[i].data[1] == 'i' || c[i].data[1] == 'I') &&
+            (c[i].data[2] == 'l' || c[i].data[2] == 'L'))
+           )
+        {
+            size += 2;      // for enclosing quotes
+        }
 
+        size += c[i].len;
+        size += 1;          // for following SP
+    }
 
-    size += sizeof(" STARTTLS") - 1;
+    if (conf->id_params.nelts > 0) {
+        --size;                 // no SP follows the last parameter
+    } else {
+        size = size - 2 + 3;    // take away the () and put nil
+    }
 
     p = ngx_pnalloc(cf->pool, size);
     if (p == NULL) {
         return NGX_CONF_ERROR;
     }
 
-    conf->starttls_capability.len = size;
-    conf->starttls_capability.data = p;
+    conf->id.len = size;
+    conf->id.data = p;
+
+    p = ngx_cpymem (p, "* ID ", sizeof ("* ID ") -1);
+
+    if (conf->id_params.nelts > 0) 
+    {
+        *p++ = '(';
+        
+        for (i = 0; i < conf->id_params.nelts; ++i)
+        {
+            if (!((c[i].len == 3) &&
+                (c[i].data[0] == 'n' || c[i].data[0] == 'N') &&
+                (c[i].data[1] == 'i' || c[i].data[1] == 'I') &&
+                (c[i].data[2] == 'l' || c[i].data[2] == 'L'))
+               )
+            {
+                *p++ = '"';
+                p = ngx_cpymem(p, c[i].data, c[i].len);
+                *p++ = '"';
+            }
+            else
+            {
+                p = ngx_cpymem(p, c[i].data, c[i].len);
+            }
+
+            if (i < conf->id_params.nelts - 1)
+                *p++ = ' ';
+        }
+
+        *p++ = ')';
+    }
+    else
+    {
+        p = ngx_cpymem (p, "nil", sizeof("nil") - 1);
+    }
 
-    p = ngx_cpymem(p, conf->capability.data,
-                   conf->capability.len - (sizeof(CRLF) - 1));
-    p = ngx_cpymem(p, " STARTTLS", sizeof(" STARTTLS") - 1);
     *p++ = CR; *p = LF;
+     ngx_conf_merge_value (conf->literalauth, prev->literalauth,1);
+     ngx_conf_merge_str_value (conf->ua_name, prev->ua_name, "ZCS");
+     ngx_conf_merge_str_value (conf->ua_version, prev->ua_version, "Unknown Version");
 
+     return NGX_CONF_OK;
+}
 
-    size = (auth - conf->capability.data) + sizeof(CRLF) - 1
-            + sizeof(" STARTTLS LOGINDISABLED") - 1;
+static char *
+ngx_mail_imap_id (ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    char *p = conf;
+    ngx_mail_imap_srv_conf_t  *iscf;
+    ngx_str_t   *c, *value, *elt;
+    ngx_uint_t  i;
+    ngx_array_t *a;
+
+    iscf = (ngx_mail_imap_srv_conf_t *)conf;
+
+    value = cf->args->elts;
+
+    if (cf->args->nelts % 2 == 0)
+    {
+        // ID response must contain id param field-value pairs
+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, 
+            "unmatched pair in IMAP ID string: %V",
+            value + cf->args->nelts - 1);
 
-    p = ngx_pnalloc(cf->pool, size);
-    if (p == NULL) {
         return NGX_CONF_ERROR;
     }
+    else
+    {
+        a = (ngx_array_t *) (p + cmd->offset);
+        for (i = 1; i < cf->args->nelts; ++i)
+        {
+            c = ngx_array_push (a);
+            if (c == NULL) {
+                return NGX_CONF_ERROR;
+            }
 
-    conf->starttls_only_capability.len = size;
-    conf->starttls_only_capability.data = p;
+            *c = value[i];
+        }
 
-    p = ngx_cpymem(p, conf->capability.data,
-                   auth - conf->capability.data);
-    p = ngx_cpymem(p, " STARTTLS LOGINDISABLED",
-                   sizeof(" STARTTLS LOGINDISABLED") - 1);
-    *p++ = CR; *p = LF;
+        for (i = 0; i < a->nelts; i += 2 ) {
+            elt = ((ngx_str_t *) a->elts + i);
+            if (elt->len == sizeof ("NAME") - 1 &&
+                (elt->data[0] == 'N' || elt->data[0] == 'n') &&
+                (elt->data[1] == 'A' || elt->data[1] == 'a') &&
+                (elt->data[2] == 'M' || elt->data[2] == 'm') &&
+                (elt->data[3] == 'E' || elt->data[0] == 'e')) {
+                iscf->ua_name = *(elt + 1);
+            }else if (elt->len == sizeof ("VERSION") - 1 &&
+                (elt->data[0] == 'V' || elt->data[0] == 'v') &&
+                (elt->data[1] == 'E' || elt->data[1] == 'e') &&
+                (elt->data[2] == 'R' || elt->data[2] == 'r') &&
+                (elt->data[3] == 'S' || elt->data[3] == 's') &&
+                (elt->data[4] == 'I' || elt->data[4] == 'i') &&
+                (elt->data[5] == 'O' || elt->data[5] == 'o') &&
+                (elt->data[6] == 'N' || elt->data[6] == 'n')) {
+                iscf->ua_version = *(elt + 1);
+            }
+        }
 
-    return NGX_CONF_OK;
+        return NGX_CONF_OK;
+    }
 }
diff -ur nginx-1.7.1/src/mail/ngx_mail_imap_module.h nginx-1.7.1-zimbra/src/mail/ngx_mail_imap_module.h
--- nginx-1.7.1/src/mail/ngx_mail_imap_module.h	2014-05-27 06:58:10.000000000 -0700
+++ nginx-1.7.1-zimbra/src/mail/ngx_mail_imap_module.h	2014-07-23 12:24:10.000000000 -0700
@@ -24,6 +24,14 @@
     ngx_uint_t   auth_methods;
 
     ngx_array_t  capabilities;
+    ngx_array_t  id_params;
+    ngx_str_t    id;
+
+    ngx_str_t    ua_name;    /* user agent name coming from ID field "NAME" */
+    ngx_str_t    ua_version; /* user agent version coming from ID field "VERSION" */
+
+    ngx_flag_t   literalauth;
+    ngx_str_t    greeting;
 } ngx_mail_imap_srv_conf_t;
 
 
diff -ur nginx-1.7.1/src/mail/ngx_mail_parse.c nginx-1.7.1-zimbra/src/mail/ngx_mail_parse.c
--- nginx-1.7.1/src/mail/ngx_mail_parse.c	2014-05-27 06:58:10.000000000 -0700
+++ nginx-1.7.1-zimbra/src/mail/ngx_mail_parse.c	2014-07-23 12:24:10.000000000 -0700
@@ -13,20 +13,99 @@
 #include <ngx_mail_imap_module.h>
 #include <ngx_mail_smtp_module.h>
 
+static ngx_int_t ngx_mail_imap_parse_id_params(ngx_mail_session_t *s, u_char *p);
+
+typedef enum {
+        swi_start = 0,
+        swi_spaces_before_command,
+        swi_command,
+        swi_spaces_before_argument,
+        swi_argument,
+        swi_backslash,
+        swi_literal,
+        swi_no_sync_literal_argument,
+        swi_start_literal_argument,
+        swi_literal_argument,
+        swi_end_literal_argument,
+        swi_almost_done,
+        swi_begin_idparams = 15,
+        swi_end_idparams,
+        swi_done_idparams,
+        swi_almost_done_idparams,
+        swi_begin_idfield,
+        swi_id_n,
+        swi_id_ni,
+        swi_id_nil,
+        swi_idfield,
+        swi_idfield_len,
+        swi_idfield_len_plus,
+        swi_begin_idfield_l,
+        swi_idfield_l,
+        swi_SP_before_idvalue,
+        swi_X_before_idfield,
+        swi_begin_idvalue,
+        swi_idvalue,
+        swi_idvalue_n,
+        swi_idvalue_ni,
+        swi_idvalue_nil,
+        swi_idvalue_len,
+        swi_idvalue_len_plus,
+        swi_begin_idvalue_l,
+        swi_idvalue_l,
+} ngx_imap_parse_state_e;
+
+typedef enum {
+    swp_start = 0,
+    swp_spaces_before_argument,
+    swp_argument,
+    swp_almost_done
+} ngx_pop3_parse_state_e;
+
+typedef enum {
+    sws_start = 0,
+    sws_command,
+    sws_spaces_before_argument,
+    sws_argument,
+    sws_almost_done,
+    sws_invalid
+} ngx_smtp_parse_state_e;
+
+inline void ngx_mail_set_imap_parse_state_start(ngx_mail_session_t * s) {
+    s->state = swi_start;
+}
+
+inline void ngx_mail_set_pop3_parse_state_start(ngx_mail_session_t * s) {
+    s->state = swp_start;
+}
+
+inline void ngx_mail_set_smtp_parse_state_start(ngx_mail_session_t * s) {
+    s->state = sws_start;
+}
+
+inline void ngx_mail_set_imap_parse_state_argument(ngx_mail_session_t * s) {
+    s->state = swi_argument;
+}
+
+inline void ngx_mail_set_pop3_parse_state_argument(ngx_mail_session_t * s) {
+    s->state = swp_argument;
+}
+
+inline void ngx_mail_set_smtp_parse_state_argument(ngx_mail_session_t * s) {
+    s->state = sws_argument;
+}
+
+inline void ngx_mail_reset_parse_buffer(ngx_mail_session_t * s) {
+    s->buffer->pos = s->buffer->start;
+    s->buffer->last = s->buffer->start;
+}
 
 ngx_int_t
 ngx_mail_pop3_parse_command(ngx_mail_session_t *s)
 {
     u_char      ch, *p, *c, c0, c1, c2, c3;
     ngx_str_t  *arg;
-    enum {
-        sw_start = 0,
-        sw_spaces_before_argument,
-        sw_argument,
-        sw_almost_done
-    } state;
 
-    state = s->state;
+    ngx_pop3_parse_state_e state = s->state;
 
     for (p = s->buffer->pos; p < s->buffer->last; p++) {
         ch = *p;
@@ -34,7 +113,7 @@
         switch (state) {
 
         /* POP3 command */
-        case sw_start:
+        case swp_start:
             if (ch == ' ' || ch == CR || ch == LF) {
                 c = s->buffer->start;
 
@@ -87,10 +166,10 @@
 
                 switch (ch) {
                 case ' ':
-                    state = sw_spaces_before_argument;
+                    state = swp_spaces_before_argument;
                     break;
                 case CR:
-                    state = sw_almost_done;
+                    state = swp_almost_done;
                     break;
                 case LF:
                     goto done;
@@ -104,12 +183,12 @@
 
             break;
 
-        case sw_spaces_before_argument:
+        case swp_spaces_before_argument:
             switch (ch) {
             case ' ':
                 break;
             case CR:
-                state = sw_almost_done;
+                state = swp_almost_done;
                 s->arg_end = p;
                 break;
             case LF:
@@ -117,7 +196,7 @@
                 goto done;
             default:
                 if (s->args.nelts <= 2) {
-                    state = sw_argument;
+                    state = swp_argument;
                     s->arg_start = p;
                     break;
                 }
@@ -125,7 +204,7 @@
             }
             break;
 
-        case sw_argument:
+        case swp_argument:
             switch (ch) {
 
             case ' ':
@@ -155,10 +234,10 @@
 
                 switch (ch) {
                 case ' ':
-                    state = sw_spaces_before_argument;
+                    state = swp_spaces_before_argument;
                     break;
                 case CR:
-                    state = sw_almost_done;
+                    state = swp_almost_done;
                     break;
                 case LF:
                     goto done;
@@ -170,7 +249,7 @@
             }
             break;
 
-        case sw_almost_done:
+        case swp_almost_done:
             switch (ch) {
             case LF:
                 goto done;
@@ -199,13 +278,11 @@
         s->arg_start = NULL;
     }
 
-    s->state = (s->command != NGX_POP3_AUTH) ? sw_start : sw_argument;
-
     return NGX_OK;
 
 invalid:
 
-    s->state = sw_start;
+    s->state = swp_start;
     s->arg_start = NULL;
 
     return NGX_MAIL_PARSE_INVALID_COMMAND;
@@ -216,23 +293,23 @@
 ngx_mail_imap_parse_command(ngx_mail_session_t *s)
 {
     u_char      ch, *p, *c;
+    ngx_int_t   rc;
     ngx_str_t  *arg;
-    enum {
-        sw_start = 0,
-        sw_spaces_before_command,
-        sw_command,
-        sw_spaces_before_argument,
-        sw_argument,
-        sw_backslash,
-        sw_literal,
-        sw_no_sync_literal_argument,
-        sw_start_literal_argument,
-        sw_literal_argument,
-        sw_end_literal_argument,
-        sw_almost_done
-    } state;
+    p = NULL; /* for avoid warning */
+    ngx_imap_parse_state_e state = s->state;
+
+    if(state >= swi_begin_idparams) { /* beyond the states handled in ID parse function */
+        rc = ngx_mail_imap_parse_id_params(s, s->buffer->pos);
+        switch (rc) {
+        case NGX_OK:
+             goto done;
+        case NGX_MAIL_PARSE_INVALID_COMMAND:
+             goto invalid;
+        default: /* NGX_ERROR, NGX_AGAIN or NGX_IMAP_NEXT */
+             return rc;
+        }
+    }
 
-    state = s->state;
 
     for (p = s->buffer->pos; p < s->buffer->last; p++) {
         ch = *p;
@@ -240,46 +317,74 @@
         switch (state) {
 
         /* IMAP tag */
-        case sw_start:
+        case swi_start:
             switch (ch) {
             case ' ':
-                s->tag.len = p - s->buffer->start + 1;
+                s->tag.len = p - s->buffer->start;
                 s->tag.data = s->buffer->start;
-                state = sw_spaces_before_command;
+                state = swi_spaces_before_command;
+                s->eargs = 0;
                 break;
-            case CR:
-                s->state = sw_start;
-                return NGX_MAIL_PARSE_INVALID_COMMAND;
-            case LF:
-                s->state = sw_start;
+            case CR: /* walk through */
+            case LF: /* walk through */
+            case '\x0':
+                s->tag.len = p - s->buffer->start;
+                s->tag.data = s->buffer->start;
+                s->state = swi_start;
                 return NGX_MAIL_PARSE_INVALID_COMMAND;
             }
             break;
 
-        case sw_spaces_before_command:
+        case swi_spaces_before_command:
             switch (ch) {
             case ' ':
                 break;
             case CR:
-                s->state = sw_start;
+                s->state = swi_start;
                 return NGX_MAIL_PARSE_INVALID_COMMAND;
             case LF:
-                s->state = sw_start;
+                s->state = swi_start;
+                return NGX_MAIL_PARSE_INVALID_COMMAND;
+            case '\x0':
+                s->state = swi_start;
                 return NGX_MAIL_PARSE_INVALID_COMMAND;
             default:
                 s->cmd_start = p;
-                state = sw_command;
+                state = swi_command;
                 break;
             }
             break;
 
-        case sw_command:
+        case swi_command:
             if (ch == ' ' || ch == CR || ch == LF) {
 
                 c = s->cmd_start;
 
                 switch (p - c) {
 
+                case 2:
+                    if ((c[0] == 'I' || c[0] == 'i')
+                        && (c[1] == 'D' || c[1] == 'd'))
+                    {
+                        s->command = NGX_IMAP_ID;
+                        /* RFC 2971 */
+                        ngx_int_t rc;
+                        s->state = swi_begin_idparams;
+                        p++; //move to the next character
+                        rc = ngx_mail_imap_parse_id_params(s, p);
+                        switch (rc) {
+                        case NGX_OK:
+                            goto done;
+                        case NGX_MAIL_PARSE_INVALID_COMMAND:
+                            goto invalid;
+                        default: /* NGX_ERROR or NGX_IMAP_NEXT */
+                            return rc;
+                        }
+                    } else {
+                        goto invalid;
+                    }
+                    break;
+
                 case 4:
                     if ((c[0] == 'N' || c[0] == 'n')
                         && (c[1] == 'O'|| c[1] == 'o')
@@ -287,7 +392,7 @@
                         && (c[3] == 'P'|| c[3] == 'p'))
                     {
                         s->command = NGX_IMAP_NOOP;
-
+                        s->eargs = 0;
                     } else {
                         goto invalid;
                     }
@@ -301,7 +406,7 @@
                         && (c[4] == 'N'|| c[4] == 'n'))
                     {
                         s->command = NGX_IMAP_LOGIN;
-
+                        s->eargs = 2;
                     } else {
                         goto invalid;
                     }
@@ -316,7 +421,7 @@
                         && (c[5] == 'T'|| c[5] == 't'))
                     {
                         s->command = NGX_IMAP_LOGOUT;
-
+                        s->eargs = 0;
                     } else {
                         goto invalid;
                     }
@@ -334,7 +439,7 @@
                         && (c[7] == 'S'|| c[7] == 's'))
                     {
                         s->command = NGX_IMAP_STARTTLS;
-
+                        s->eargs = 0;
                     } else {
                         goto invalid;
                     }
@@ -354,7 +459,7 @@
                         && (c[9] == 'Y'|| c[9] == 'y'))
                     {
                         s->command = NGX_IMAP_CAPABILITY;
-
+                        s->eargs = 0;
                     } else {
                         goto invalid;
                     }
@@ -374,8 +479,12 @@
                         && (c[10] == 'T'|| c[10] == 't')
                         && (c[11] == 'E'|| c[11] == 'e'))
                     {
-                        s->command = NGX_IMAP_AUTHENTICATE;
-
+                        if (ch != ' ') {
+                            goto invalid;
+                        } else {
+                            s->command = NGX_IMAP_AUTHENTICATE;
+                            s->eargs = 1;
+                        }
                     } else {
                         goto invalid;
                     }
@@ -387,10 +496,13 @@
 
                 switch (ch) {
                 case ' ':
-                    state = sw_spaces_before_argument;
+                    if (s->command == NGX_IMAP_CAPABILITY) {
+                        goto invalid;
+                    }
+                    state = swi_spaces_before_argument;
                     break;
                 case CR:
-                    state = sw_almost_done;
+                    state = swi_almost_done;
                     break;
                 case LF:
                     goto done;
@@ -404,42 +516,48 @@
 
             break;
 
-        case sw_spaces_before_argument:
+        case swi_spaces_before_argument:
             switch (ch) {
             case ' ':
                 break;
             case CR:
-                state = sw_almost_done;
+                if (s->args.nelts == 0) {
+                    goto invalid; //no argument
+                }
+                state = swi_almost_done;
                 s->arg_end = p;
                 break;
             case LF:
+                if ( s->args.nelts == 0) {
+                    goto invalid; // no argument
+                }
                 s->arg_end = p;
                 goto done;
             case '"':
-                if (s->args.nelts <= 2) {
+                if (s->args.nelts <= s->eargs) {
                     s->quoted = 1;
                     s->arg_start = p + 1;
-                    state = sw_argument;
+                    state = swi_argument;
                     break;
                 }
                 goto invalid;
             case '{':
-                if (s->args.nelts <= 2) {
-                    state = sw_literal;
+                if (s->args.nelts <= s->eargs) {
+                    state = swi_literal;
                     break;
                 }
                 goto invalid;
             default:
-                if (s->args.nelts <= 2) {
+                if (s->args.nelts <= s->eargs) {
                     s->arg_start = p;
-                    state = sw_argument;
+                    state = swi_argument;
                     break;
                 }
                 goto invalid;
             }
             break;
 
-        case sw_argument:
+        case swi_argument:
             if (ch == ' ' && s->quoted) {
                 break;
             }
@@ -465,10 +583,10 @@
                 switch (ch) {
                 case '"':
                 case ' ':
-                    state = sw_spaces_before_argument;
+                    state = swi_spaces_before_argument;
                     break;
                 case CR:
-                    state = sw_almost_done;
+                    state = swi_almost_done;
                     break;
                 case LF:
                     goto done;
@@ -477,46 +595,52 @@
             case '\\':
                 if (s->quoted) {
                     s->backslash = 1;
-                    state = sw_backslash;
+                    state = swi_backslash;
                 }
                 break;
             }
             break;
 
-        case sw_backslash:
+        case swi_backslash:
             switch (ch) {
             case CR:
             case LF:
                 goto invalid;
+            // (RFC3501)
+            // a backslash may only escape another backslash, or a double quote
+            case '\\':
+            case '"':
+                state = swi_argument;
+                break;
             default:
-                state = sw_argument;
+                goto invalid;
             }
             break;
 
-        case sw_literal:
+        case swi_literal:
             if (ch >= '0' && ch <= '9') {
                 s->literal_len = s->literal_len * 10 + (ch - '0');
                 break;
             }
             if (ch == '}') {
-                state = sw_start_literal_argument;
+                state = swi_start_literal_argument;
                 break;
             }
             if (ch == '+') {
-                state = sw_no_sync_literal_argument;
+                state = swi_no_sync_literal_argument;
                 break;
             }
             goto invalid;
 
-        case sw_no_sync_literal_argument:
+        case swi_no_sync_literal_argument:
             if (ch == '}') {
                 s->no_sync_literal = 1;
-                state = sw_start_literal_argument;
+                state = swi_start_literal_argument;
                 break;
             }
             goto invalid;
 
-        case sw_start_literal_argument:
+        case swi_start_literal_argument:
             switch (ch) {
             case CR:
                 break;
@@ -524,10 +648,10 @@
                 s->buffer->pos = p + 1;
                 s->arg_start = p + 1;
                 if (s->no_sync_literal == 0) {
-                    s->state = sw_literal_argument;
+                    s->state = swi_literal_argument;
                     return NGX_IMAP_NEXT;
                 }
-                state = sw_literal_argument;
+                state = swi_literal_argument;
                 s->no_sync_literal = 0;
                 break;
             default:
@@ -535,7 +659,7 @@
             }
             break;
 
-        case sw_literal_argument:
+        case swi_literal_argument:
             if (s->literal_len && --s->literal_len) {
                 break;
             }
@@ -547,36 +671,38 @@
             arg->len = p + 1 - s->arg_start;
             arg->data = s->arg_start;
             s->arg_start = NULL;
-            state = sw_end_literal_argument;
+            state = swi_end_literal_argument;
 
             break;
 
-        case sw_end_literal_argument:
+        case swi_end_literal_argument:
             switch (ch) {
             case '{':
-                if (s->args.nelts <= 2) {
-                    state = sw_literal;
+                if (s->args.nelts <= s->eargs) {
+                    state = swi_literal;
                     break;
                 }
                 goto invalid;
             case CR:
-                state = sw_almost_done;
+                state = swi_almost_done;
                 break;
             case LF:
                 goto done;
             default:
-                state = sw_spaces_before_argument;
+                state = swi_spaces_before_argument;
                 break;
             }
             break;
 
-        case sw_almost_done:
+        case swi_almost_done:
             switch (ch) {
             case LF:
                 goto done;
             default:
                 goto invalid;
             }
+        default:
+            break; /* for avoid warning only */
         }
     }
 
@@ -604,13 +730,11 @@
         s->literal_len = 0;
     }
 
-    s->state = (s->command != NGX_IMAP_AUTHENTICATE) ? sw_start : sw_argument;
-
     return NGX_OK;
 
 invalid:
 
-    s->state = sw_start;
+    s->state = swi_start;
     s->quoted = 0;
     s->no_sync_literal = 0;
     s->literal_len = 0;
@@ -618,22 +742,499 @@
     return NGX_MAIL_PARSE_INVALID_COMMAND;
 }
 
+static ngx_int_t
+ngx_mail_imap_parse_id_params(ngx_mail_session_t *s, u_char *p)
+{
+    u_char ch;
+    ngx_imap_parse_state_e state;
+    ngx_str_t *arg;
+    state = s->state;
+
+    for (; p < s->buffer->last; p++) {
+        ch = *p;
+        switch(state) {
+        case swi_begin_idparams:
+            switch (ch) {
+                case '(':
+                    state = swi_begin_idfield;
+                    break;
+                case 'n':
+                case 'N':
+                    state = swi_id_n;
+                    break;
+                default:
+                    ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+                        "swi_begin_idparams: expected (/n/N, got '%c'", ch);
+                    return NGX_MAIL_PARSE_INVALID_COMMAND;
+            }
+            break;
+
+        case swi_end_idparams:
+            switch (ch)
+            {
+                case ')':
+                    state = swi_done_idparams;
+                    break;
+                default:
+                    ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+                        "swi_end_idparams: expected ), got '%c'", ch);
+                    return NGX_MAIL_PARSE_INVALID_COMMAND;
+            }
+
+            break;
+
+        case swi_done_idparams:
+            switch (ch)
+            {
+                case CR:
+                    state = swi_almost_done;
+                    break;
+                case LF:
+                    return NGX_OK;
+                default:
+                    ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+                        "swi_done_idparams: expected CR/LF, got '%c'", ch);
+                    return NGX_MAIL_PARSE_INVALID_COMMAND;
+            }
+            break;
+
+        case swi_id_n:
+            switch (ch) {
+                case 'i':
+                case 'I':
+                    state = swi_id_ni;
+                    break;
+                default:
+                    ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+                        "swi_id_n: expected i/I, got '%c'", ch);
+                    return NGX_MAIL_PARSE_INVALID_COMMAND;
+            }
+            break;
+
+        case swi_id_ni:
+            switch (ch) {
+                case 'l':
+                case 'L':
+                    state = swi_id_nil;
+                    break;
+                default:
+                    ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+                        "swi_id_ni: expected l/L, got '%c'", ch);
+                    return NGX_MAIL_PARSE_INVALID_COMMAND;
+            }
+            break;
+
+        case swi_id_nil:
+            switch (ch) {
+                case CR:
+                    state = swi_almost_done;
+                    break;
+                case LF:
+                    return NGX_OK;
+                default:
+                    return NGX_MAIL_PARSE_INVALID_COMMAND;
+            }
+            break;
+
+        case swi_begin_idfield:
+            switch (ch) {
+                case '{':
+                    s->literal_len = 0;
+                    state = swi_idfield_len;
+                    break;
+                case '"':
+                    s->quoted = 1;
+                    s->backslash = 0;
+                    s->arg_start = p+1;
+                    state = swi_idfield;
+                    break;
+                default:
+                    ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+                        "swi_begin_idfield: expected \"/{, got '%c'", ch);
+                     return NGX_MAIL_PARSE_INVALID_COMMAND;
+            }
+            break;
+
+        case swi_idfield_len:
+            if (ch >= '0' && ch <= '9') {
+                s->literal_len = s->literal_len * 10 + (ch - '0');
+                break;
+            }
+            if (ch == '+') {
+                state = swi_idfield_len_plus;   /* literalplus stuff */
+                break;
+            }
+            if (ch == '}') {
+                s->no_sync_literal = 0;
+                state = swi_begin_idfield_l;
+                break;
+            }
+            ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+                "swi_idfield_len: expected 0-9/+/}, got '%c'", ch);
+            return NGX_MAIL_PARSE_INVALID_COMMAND;
+
+        case swi_idfield_len_plus:
+            if (ch == '}') {
+                s->no_sync_literal = 1;
+                state = swi_begin_idfield_l;
+                break;
+            }
+            ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+                "swi_idfield_len_plus: expected }, got '%c'", ch);
+            return NGX_MAIL_PARSE_INVALID_COMMAND;
+
+        case swi_begin_idfield_l:
+            switch (ch)
+            {
+                case CR:
+                    break;
+                case LF:
+                    if (s->literal_len) {
+                        s->buffer->pos = p + 1;
+                        s->arg_start = p + 1;
+                        state = swi_idfield_l;
+                    } else {
+                        s->buffer->pos = p + 1;
+                        s->arg_start = NULL;
+                        arg = ngx_array_push (&s->args);
+                        if (arg == NULL) { return NGX_ERROR; }
+                        arg->data = (u_char *)"";
+                        arg->len = 0;
+                        state = swi_SP_before_idvalue;
+                    }
+                    if (s->no_sync_literal == 1) {
+                        s->no_sync_literal = 0;
+                        break;
+                    } else {
+                        s->state = state;
+                        return NGX_IMAP_NEXT;
+                    }
+                default:
+                    ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+                        "swi_begin_idfield_l: expected CR/LF, got '%c'", ch);
+                    return NGX_MAIL_PARSE_INVALID_COMMAND;
+            }
+            break;
+
+        case swi_idfield_l:
+            if (s->literal_len && --s->literal_len) {
+                break;
+            }
+
+            arg = ngx_array_push (&s->args);
+            if (arg == NULL) {
+                return NGX_ERROR;
+            }
+
+            arg->len = p + 1 - s->arg_start;
+            arg->data = s->arg_start;
+            s->arg_start = NULL;
+            state = swi_SP_before_idvalue;
+            break;
+
+        case swi_idfield:
+            switch (ch) {
+                case '\\':
+                    if (!s->backslash) {
+                        s->backslash = 1;
+                    } else {
+                        if (ch == '\\' && ch == '"')
+                            s->backslash = 0;
+                        else {
+                            ngx_log_debug1 (NGX_LOG_DEBUG_MAIL,
+                              s->connection->log, 0,
+                              "swi_idfield: \\ escapes non-quoted special '%c'",
+                              ch);
+                            return NGX_MAIL_PARSE_INVALID_COMMAND;
+                        }
+                    }
+                    break;
+
+                case '"':
+                    if (s->backslash) {
+                        s->backslash = 0;
+                        break;
+                    }
+                    s->quoted = 0;
+                    arg = ngx_array_push(&s->args);
+                    if (arg == NULL) {
+                        return NGX_ERROR;
+                    }
+
+                    arg->len = p - s->arg_start;
+                    arg->data = s->arg_start;
+                    s->arg_start = NULL;
+                    state = swi_SP_before_idvalue;
+                    break;
+
+                case CR:
+                case LF:
+                    ngx_log_debug0 (NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+                        "swi_idfield: CR/LF breaks id field");
+                    return NGX_MAIL_PARSE_INVALID_COMMAND;
+                default:
+                    break;
+            }
+            break;
+
+        case swi_begin_idvalue:
+            switch (ch)
+            {
+                case '"':
+                    s->quoted = 1;
+                    s->backslash = 0;
+                    s->arg_start = p+1;
+                    state = swi_idvalue;
+                    break;
+                case 'n':
+                case 'N':
+                    state = swi_idvalue_n;
+                    break;
+                case '{':
+                    s->literal_len = 0;
+                    state = swi_idvalue_len;
+                    break;
+                default:
+                    ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+                        "swi_begin_idvalue: expected \"/n/N/{, got '%c'", ch);
+                    return NGX_MAIL_PARSE_INVALID_COMMAND;
+            }
+            break;
+
+        case swi_idvalue_len:
+            if (ch >= '0' && ch <= '9') {
+                s->literal_len = s->literal_len + (ch - '0');
+                break;
+            }
+            if (ch == '+') {
+                state = swi_idvalue_len_plus;
+                break;
+            }
+            if (ch == '}') {
+                s->no_sync_literal = 0;
+                state = swi_begin_idvalue_l;
+                break;
+            }
+            ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+                "swi_idvalue_len: expected 0-9/}, got '%c'", ch);
+            return NGX_MAIL_PARSE_INVALID_COMMAND;
+
+        case swi_idvalue_len_plus:
+            if (ch == '}') {
+                s->no_sync_literal = 1;
+                state = swi_begin_idvalue_l;
+                break;
+            }
+            ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+                "swi_idvalue_len_plus: expected }, got '%c'", ch);
+            return NGX_MAIL_PARSE_INVALID_COMMAND;
+
+        case swi_begin_idvalue_l:
+            switch (ch)
+            {
+                case CR:
+                    break;
+                case LF:
+                    if (s->literal_len) {
+                        s->buffer->pos = p + 1;
+                        s->arg_start = p + 1;
+                        state = swi_idvalue_l;
+                    } else {
+                        s->buffer->pos = p + 1;
+                        s->arg_start = NULL;
+                        arg = ngx_array_push (&s->args);
+                        if (arg == NULL) { return NGX_ERROR; }
+                        arg->data = (u_char *)"";
+                        arg->len = 0;
+                        state = swi_X_before_idfield;
+                    }
+                    if (s->no_sync_literal == 1) {
+                        s->no_sync_literal = 0;
+                        break;
+                    } else {
+                        s->state = state;
+                        return NGX_IMAP_NEXT;
+                    }
+                default:
+                    ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+                        "swi_begin_idvalue_l: expected CR/LF, got '%c'", ch);
+                    return NGX_MAIL_PARSE_INVALID_COMMAND;
+            }
+            break;
+
+        case swi_idvalue_l:
+            if (s->literal_len && --s->literal_len) {
+                break;
+            }
+
+            arg = ngx_array_push (&s->args);
+            if (arg == NULL) {
+                return NGX_ERROR;
+            }
+
+            arg->len = p + 1 - s->arg_start;
+            arg->data = s->arg_start;
+            s->arg_start = NULL;
+            state = swi_X_before_idfield;
+            break;
+
+        case swi_idvalue_n:
+            switch (ch)
+            {
+                case 'i':
+                case 'I':
+                    state = swi_idvalue_ni;
+                    break;
+                default:
+                    ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+                        "swi_idvalue_n: expected i/I, got '%c'", ch);
+                    return NGX_MAIL_PARSE_INVALID_COMMAND;
+            }
+            break;
+
+        case swi_idvalue_ni:
+            switch (ch)
+            {
+                case 'l':
+                case 'L':
+                    state = swi_idvalue_nil;
+                    break;
+                default:
+                    ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+                        "swi_idvalue_ni: expected l/L, got '%c'", ch);
+                    return NGX_MAIL_PARSE_INVALID_COMMAND;
+            }
+            break;
+
+        case swi_idvalue_nil:
+            switch (ch)
+            {
+                case ' ':
+                    state = swi_begin_idfield;
+                    arg = ngx_array_push (&s->args);
+                    if (arg == NULL) {
+                        return NGX_ERROR;
+                    }
+                    arg->data = (u_char *)"";
+                    arg->len = 0;
+                    break;
+                case ')':
+                    state = swi_done_idparams;
+                    arg = ngx_array_push (&s->args);
+                    if (arg == NULL) {
+                        return NGX_ERROR;
+                    }
+                    arg->data = (u_char *)"";
+                    arg->len = 0;
+                    break;
+                default:
+                    ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+                        "swi_idvalue_nil: expected SP/), got '%c'", ch);
+                    return NGX_MAIL_PARSE_INVALID_COMMAND;
+            }
+            break;
+
+        case swi_SP_before_idvalue:
+            switch (ch)
+            {
+                case ' ':
+                    state = swi_begin_idvalue;
+                    break;
+                default:
+                    ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+                        "swi_SP_before_idvalue: expected SP, got '%c'", ch);
+                    return NGX_MAIL_PARSE_INVALID_COMMAND;
+            }
+            break;
+
+        case swi_X_before_idfield:
+            switch (ch)
+            {
+                case ' ':
+                    state = swi_begin_idfield;
+                    break;
+                case ')':
+                    state = swi_done_idparams;
+                    break;
+                default:
+                    ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+                        "swi_X_before_idfield: expected SP/), got '%c'", ch);
+                    return NGX_MAIL_PARSE_INVALID_COMMAND;
+            }
+            break;
+
+        case swi_idvalue:
+            switch (ch)
+            {
+                case '\\':
+                    if (!s->backslash) {
+                        s->backslash = 1;
+                    } else {
+                        if (ch == '\\' || ch == '"')
+                            s->backslash = 0;
+                        else {
+                            ngx_log_debug1 (NGX_LOG_DEBUG_MAIL,
+                              s->connection->log, 0,
+                              "swi_idvalue: \\ escapes non-quoted special '%c'",
+                              ch);
+                            return NGX_MAIL_PARSE_INVALID_COMMAND;
+                        }
+                    }
+                    break;
+
+                case '"':
+                    if (s->backslash)
+                    {
+                        s->backslash = 0;
+                        break;
+                    }
+                    s->quoted = 0;
+                    arg = ngx_array_push (&s->args);
+                    if (arg == NULL) {
+                        return NGX_ERROR;
+                    }
+
+                    arg->len = p - s->arg_start;
+                    arg->data = s->arg_start;
+                    s->arg_start = NULL;
+                    state = swi_X_before_idfield;
+                    break;
+
+                case CR:
+                case LF:
+                    ngx_log_debug0 (NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+                        "swi_idvalue: CR/LF breaks id value");
+                    return NGX_MAIL_PARSE_INVALID_COMMAND;
+                default:
+                    break;
+            }
+            break;
+        case swi_almost_done:
+            switch (ch) {
+            case LF:
+                return NGX_OK;
+            default:
+                return NGX_MAIL_PARSE_INVALID_COMMAND;
+            }
+
+        default:
+            break; /* for avoid warning only */
+        } /* switch (state) */
+    } /* for */
+
+    s->buffer->pos = p;
+    s->state = state;
+
+    return NGX_AGAIN;
+}
 
 ngx_int_t
 ngx_mail_smtp_parse_command(ngx_mail_session_t *s)
 {
     u_char      ch, *p, *c, c0, c1, c2, c3;
     ngx_str_t  *arg;
-    enum {
-        sw_start = 0,
-        sw_command,
-        sw_invalid,
-        sw_spaces_before_argument,
-        sw_argument,
-        sw_almost_done
-    } state;
 
-    state = s->state;
+    ngx_smtp_parse_state_e state = s->state;
 
     for (p = s->buffer->pos; p < s->buffer->last; p++) {
         ch = *p;
@@ -641,13 +1242,13 @@
         switch (state) {
 
         /* SMTP command */
-        case sw_start:
+        case sws_start:
             s->cmd_start = p;
-            state = sw_command;
+            state = sws_command;
 
             /* fall through */
 
-        case sw_command:
+        case sws_command:
             if (ch == ' ' || ch == CR || ch == LF) {
                 c = s->cmd_start;
 
@@ -732,10 +1333,10 @@
 
                 switch (ch) {
                 case ' ':
-                    state = sw_spaces_before_argument;
+                    state = sws_spaces_before_argument;
                     break;
                 case CR:
-                    state = sw_almost_done;
+                    state = sws_almost_done;
                     break;
                 case LF:
                     goto done;
@@ -749,15 +1350,15 @@
 
             break;
 
-        case sw_invalid:
+        case sws_invalid:
             goto invalid;
 
-        case sw_spaces_before_argument:
+        case sws_spaces_before_argument:
             switch (ch) {
             case ' ':
                 break;
             case CR:
-                state = sw_almost_done;
+                state = sws_almost_done;
                 s->arg_end = p;
                 break;
             case LF:
@@ -765,7 +1366,7 @@
                 goto done;
             default:
                 if (s->args.nelts <= 10) {
-                    state = sw_argument;
+                    state = sws_argument;
                     s->arg_start = p;
                     break;
                 }
@@ -773,7 +1374,7 @@
             }
             break;
 
-        case sw_argument:
+        case sws_argument:
             switch (ch) {
             case ' ':
             case CR:
@@ -788,10 +1389,10 @@
 
                 switch (ch) {
                 case ' ':
-                    state = sw_spaces_before_argument;
+                    state = sws_spaces_before_argument;
                     break;
                 case CR:
-                    state = sw_almost_done;
+                    state = sws_almost_done;
                     break;
                 case LF:
                     goto done;
@@ -803,7 +1404,7 @@
             }
             break;
 
-        case sw_almost_done:
+        case sws_almost_done:
             switch (ch) {
             case LF:
                 goto done;
@@ -832,20 +1433,18 @@
         s->arg_start = NULL;
     }
 
-    s->state = (s->command != NGX_SMTP_AUTH) ? sw_start : sw_argument;
-
     return NGX_OK;
 
 invalid:
 
-    s->state = sw_invalid;
+    s->state = sws_invalid;
     s->arg_start = NULL;
 
     /* skip invalid command till LF */
 
     for (p = s->buffer->pos; p < s->buffer->last; p++) {
         if (*p == LF) {
-            s->state = sw_start;
+            s->state = sws_start;
             p++;
             break;
         }
@@ -860,13 +1459,7 @@
 ngx_int_t
 ngx_mail_auth_parse(ngx_mail_session_t *s, ngx_connection_t *c)
 {
-    ngx_str_t                 *arg;
-
-#if (NGX_MAIL_SSL)
-    if (ngx_mail_starttls_only(s, c)) {
-        return NGX_MAIL_PARSE_INVALID_COMMAND;
-    }
-#endif
+    ngx_str_t   *arg;
 
     if (s->args.nelts == 0) {
         return NGX_MAIL_PARSE_INVALID_COMMAND;
@@ -882,7 +1475,7 @@
                 return NGX_MAIL_AUTH_LOGIN;
             }
 
-            if (s->args.nelts == 2) {
+            if (s->args.nelts == 2) { //initial response
                 return NGX_MAIL_AUTH_LOGIN_USERNAME;
             }
 
@@ -895,14 +1488,28 @@
                 return NGX_MAIL_AUTH_PLAIN;
             }
 
-            if (s->args.nelts == 2) {
-                return ngx_mail_auth_plain(s, c, 1);
+            if (s->args.nelts == 2) { //initial response
+                return NGX_MAIL_AUTH_PLAIN_IR;
             }
         }
 
         return NGX_MAIL_PARSE_INVALID_COMMAND;
     }
 
+    if (arg[0].len == 6) {
+        if (ngx_strncasecmp(arg[0].data, (u_char *) "GSSAPI", 6) == 0 ) {
+            if (s->args.nelts == 1) {
+            	return NGX_MAIL_AUTH_GSSAPI;
+            }
+
+            if (s->args.nelts == 2) { //initial response
+            	return NGX_MAIL_AUTH_GSSAPI_IR;
+            }
+        } 
+       
+        return NGX_MAIL_PARSE_INVALID_COMMAND;
+    }
+
     if (arg[0].len == 8) {
 
         if (s->args.nelts != 1) {
@@ -914,5 +1521,5 @@
         }
     }
 
-    return NGX_MAIL_PARSE_INVALID_COMMAND;
+    return NGX_MAIL_PARSE_INVALID_AUTH_MECH;
 }
diff -ur nginx-1.7.1/src/mail/ngx_mail_pop3_handler.c nginx-1.7.1-zimbra/src/mail/ngx_mail_pop3_handler.c
--- nginx-1.7.1/src/mail/ngx_mail_pop3_handler.c	2014-05-27 06:58:10.000000000 -0700
+++ nginx-1.7.1-zimbra/src/mail/ngx_mail_pop3_handler.c	2014-07-23 12:24:10.000000000 -0700
@@ -4,6 +4,10 @@
  * Copyright (C) Nginx, Inc.
  */
 
+/*
+ * Portions Copyright (c) Zimbra Software, LLC. [1998-2011]. All Rights Reserved.
+ */
+
 
 #include <ngx_config.h>
 #include <ngx_core.h>
@@ -21,13 +25,18 @@
 static ngx_int_t ngx_mail_pop3_auth(ngx_mail_session_t *s, ngx_connection_t *c);
 
 
-static u_char  pop3_greeting[] = "+OK POP3 ready" CRLF;
+/*static u_char  pop3_greeting[] = "+OK POP3 ready" CRLF; zimbra uses the greeting specified by the directive */
 static u_char  pop3_ok[] = "+OK" CRLF;
 static u_char  pop3_next[] = "+ " CRLF;
+static u_char  pop3_gssapi_next[] = "+ " CRLF;
 static u_char  pop3_username[] = "+ VXNlcm5hbWU6" CRLF;
 static u_char  pop3_password[] = "+ UGFzc3dvcmQ6" CRLF;
 static u_char  pop3_invalid_command[] = "-ERR invalid command" CRLF;
-
+static u_char  pop3_unsupported_mech[] = "-ERR mechanism not supported" CRLF;
+static u_char  pop3_nocleartext[] = "-ERR cleartext logins disabled" CRLF;
+static u_char  pop3_authaborted[] = "-ERR authentication aborted" CRLF;
+static u_char  pop3_login_failed[] = "-ERR invalid username/password" CRLF;
+static u_char  pop3_auth_failed[] = "-ERR line is too long" CRLF;
 
 void
 ngx_mail_pop3_init_session(ngx_mail_session_t *s, ngx_connection_t *c)
@@ -47,20 +56,20 @@
             return;
         }
 
-        s->out.data = ngx_pnalloc(c->pool, sizeof(pop3_greeting) + s->salt.len);
+        s->out.data = ngx_pnalloc(c->pool, pscf->greeting.len + s->salt.len - 1);
         if (s->out.data == NULL) {
             ngx_mail_session_internal_server_error(s);
             return;
         }
 
-        p = ngx_cpymem(s->out.data, pop3_greeting, sizeof(pop3_greeting) - 3);
+        p = ngx_cpymem(s->out.data, pscf->greeting.data, pscf->greeting.len - 2);
         *p++ = ' ';
         p = ngx_cpymem(p, s->salt.data, s->salt.len);
 
         s->out.len = p - s->out.data;
 
     } else {
-        ngx_str_set(&s->out, pop3_greeting);
+        s->out = pscf->greeting;
     }
 
     c->read->handler = ngx_mail_pop3_init_protocol;
@@ -80,6 +89,7 @@
 {
     ngx_connection_t    *c;
     ngx_mail_session_t  *s;
+    ngx_mail_pop3_srv_conf_t  *pscf;
 
     c = rev->data;
 
@@ -102,13 +112,16 @@
             return;
         }
 
-        s->buffer = ngx_create_temp_buf(c->pool, 128);
+        pscf = ngx_mail_get_module_srv_conf(s, ngx_mail_pop3_module);
+
+        s->buffer = ngx_create_temp_buf(c->pool, pscf->client_buffer_size);
         if (s->buffer == NULL) {
             ngx_mail_session_internal_server_error(s);
             return;
         }
     }
 
+    ngx_mail_set_pop3_parse_state_start(s);
     s->mail_state = ngx_pop3_start;
     c->read->handler = ngx_mail_pop3_auth_state;
 
@@ -160,6 +173,7 @@
 
             case NGX_POP3_USER:
                 rc = ngx_mail_pop3_user(s, c);
+                s->mail_state = ngx_pop3_user;
                 break;
 
             case NGX_POP3_CAPA:
@@ -198,6 +212,7 @@
 
             case NGX_POP3_PASS:
                 rc = ngx_mail_pop3_pass(s, c);
+                s->mail_state = ngx_pop3_user;
                 break;
 
             case NGX_POP3_CAPA:
@@ -224,15 +239,16 @@
 
         case ngx_pop3_auth_login_username:
             rc = ngx_mail_auth_login_username(s, c, 0);
-
-            ngx_str_set(&s->out, pop3_password);
-            s->mail_state = ngx_pop3_auth_login_password;
+            if(rc == NGX_MAIL_AUTH_ARGUMENT) {
+                ngx_str_set(&s->out, pop3_password);
+                s->mail_state = ngx_pop3_auth_login_password;
+            }
             break;
 
         case ngx_pop3_auth_login_password:
             rc = ngx_mail_auth_login_password(s, c);
             break;
-
+            
         case ngx_pop3_auth_plain:
             rc = ngx_mail_auth_plain(s, c, 0);
             break;
@@ -240,39 +256,84 @@
         case ngx_pop3_auth_cram_md5:
             rc = ngx_mail_auth_cram_md5(s, c);
             break;
+            
+        case ngx_pop3_auth_gssapi:
+            {
+                ngx_str_t output;
+                ngx_str_set(&output, "");
+                rc = ngx_mail_auth_gssapi(s, c, &output);
+                if (rc == NGX_MAIL_AUTH_ARGUMENT) {
+                    s->mail_state = ngx_pop3_auth_gssapi;
+                    s->out = output;
+                }
+                break;
+            }
         }
     }
 
     switch (rc) {
 
     case NGX_DONE:
-        ngx_mail_auth(s, c);
+        ngx_mail_do_auth(s, c);
         return;
 
+    case NGX_OK:
+        s->arg_start = NULL;
+        ngx_mail_set_pop3_parse_state_start(s);
+        break;
+
+    case NGX_MAIL_AUTH_ABORT:
+        ngx_str_set(&s->out, pop3_authaborted);
+        s->mail_state = ngx_pop3_start;
+        s->arg_start = NULL;
+        ngx_mail_set_pop3_parse_state_start(s);
+        break;
+
     case NGX_ERROR:
         ngx_mail_session_internal_server_error(s);
         return;
+    
+    case NGX_MAIL_LOGIN_FAILED:
+        ngx_str_set(&s->out, pop3_login_failed);
+        s->mail_state = ngx_pop3_start;
+        s->arg_start = NULL;
+        ngx_mail_set_pop3_parse_state_start(s);
+        break;
 
-    case NGX_MAIL_PARSE_INVALID_COMMAND:
+    case NGX_MAIL_AUTH_FAILED:
+        ngx_str_set(&s->out, pop3_auth_failed);
+        s->mail_state = ngx_pop3_start;
+        s->arg_start = NULL;
+        ngx_mail_set_pop3_parse_state_start(s);
+        break;
+
+    case NGX_MAIL_PARSE_INVALID_AUTH_MECH:
+        ngx_log_debug0 (NGX_LOG_DEBUG_MAIL, c->log, 0,
+            "unsupported POP auth mechanism");
+        ngx_str_set(&s->out, pop3_unsupported_mech);
         s->mail_state = ngx_pop3_start;
-        s->state = 0;
+        s->arg_start = NULL;
+        ngx_mail_set_pop3_parse_state_start(s);
+        break;
 
+    case NGX_MAIL_PARSE_INVALID_COMMAND:
         ngx_str_set(&s->out, pop3_invalid_command);
+    	s->mail_state = ngx_pop3_start;
+        s->arg_start = NULL;
+        ngx_mail_set_pop3_parse_state_start(s);
+        break;
 
-        /* fall through */
+    case NGX_MAIL_AUTH_ARGUMENT:
+        s->arg_start = s->buffer->start;
+        ngx_mail_set_pop3_parse_state_argument(s);
+        break;
 
-    case NGX_OK:
+    }
 
-        s->args.nelts = 0;
-        s->buffer->pos = s->buffer->start;
-        s->buffer->last = s->buffer->start;
+    s->args.nelts = 0;
+    ngx_mail_reset_parse_buffer(s);
 
-        if (s->state) {
-            s->arg_start = s->buffer->start;
-        }
-
-        ngx_mail_send(c->write);
-    }
+    ngx_mail_send(c->write);
 }
 
 static ngx_int_t
@@ -282,6 +343,7 @@
 
 #if (NGX_MAIL_SSL)
     if (ngx_mail_starttls_only(s, c)) {
+        ngx_str_set(&s->out, pop3_nocleartext);
         return NGX_MAIL_PARSE_INVALID_COMMAND;
     }
 #endif
@@ -291,6 +353,10 @@
     }
 
     arg = s->args.elts;
+    if(arg[0].len > NGX_MAIL_MAX_LOGIN_LEN) {
+        ngx_str_null(&s->login);
+        return NGX_OK;
+    }
     s->login.len = arg[0].len;
     s->login.data = ngx_pnalloc(c->pool, s->login.len);
     if (s->login.data == NULL) {
@@ -302,8 +368,6 @@
     ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,
                    "pop3 login: \"%V\"", &s->login);
 
-    s->mail_state = ngx_pop3_user;
-
     return NGX_OK;
 }
 
@@ -318,6 +382,10 @@
     }
 
     arg = s->args.elts;
+
+    if (s->login.len == 0 || arg[0].len > NGX_MAIL_MAX_PASSWORD_LEN) {
+        return NGX_MAIL_LOGIN_FAILED;
+    }
     s->passwd.len = arg[0].len;
     s->passwd.data = ngx_pnalloc(c->pool, s->passwd.len);
     if (s->passwd.data == NULL) {
@@ -328,10 +396,13 @@
 
 #if (NGX_DEBUG_MAIL_PASSWD)
     ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,
-                   "pop3 passwd: \"%V\"", &s->passwd);
+                                   "pop3 passwd: \"%V\"", &s->passwd);
 #endif
 
-    return NGX_DONE;
+     s->auth_method = NGX_MAIL_AUTH_PASSWD;
+     s->usedauth = 0;
+                   
+     return NGX_DONE;
 }
 
 
@@ -345,7 +416,7 @@
 #if (NGX_MAIL_SSL)
 
     if (stls && c->ssl == NULL) {
-        ngx_mail_ssl_conf_t  *sslcf;
+        ngx_mail_ssl_conf_t *sslcf;
 
         sslcf = ngx_mail_get_module_srv_conf(s, ngx_mail_ssl_module);
 
@@ -431,6 +502,7 @@
                    "pop3 apop: \"%V\" \"%V\"", &s->login, &s->passwd);
 
     s->auth_method = NGX_MAIL_AUTH_APOP;
+    s->usedauth = 0;
 
     return NGX_DONE;
 }
@@ -450,11 +522,15 @@
 
     pscf = ngx_mail_get_module_srv_conf(s, ngx_mail_pop3_module);
 
-    if (s->args.nelts == 0) {
-        s->out = pscf->auth_capability;
-        s->state = 0;
+//    if (s->args.nelts == 0) {
+//        s->out = pscf->auth_capability;
+//        s->state = 0;
+//
+//        return NGX_OK;
+//    }
 
-        return NGX_OK;
+    if (s->args.nelts == 0) {
+        return NGX_MAIL_PARSE_INVALID_COMMAND;
     }
 
     rc = ngx_mail_auth_parse(s, c);
@@ -462,38 +538,77 @@
     switch (rc) {
 
     case NGX_MAIL_AUTH_LOGIN:
-
+        if (!(pscf->auth_methods & NGX_MAIL_AUTH_LOGIN_ENABLED)) {
+            return NGX_MAIL_PARSE_INVALID_AUTH_MECH;
+        }
         ngx_str_set(&s->out, pop3_username);
         s->mail_state = ngx_pop3_auth_login_username;
 
-        return NGX_OK;
+        return NGX_MAIL_AUTH_ARGUMENT;
 
     case NGX_MAIL_AUTH_LOGIN_USERNAME:
-
+        if (!(pscf->auth_methods & NGX_MAIL_AUTH_LOGIN_ENABLED)) {
+            return NGX_MAIL_PARSE_INVALID_AUTH_MECH;
+        }
         ngx_str_set(&s->out, pop3_password);
         s->mail_state = ngx_pop3_auth_login_password;
 
-        return ngx_mail_auth_login_username(s, c, 1);
+        return ngx_mail_auth_login_username(s, c, 0);
 
     case NGX_MAIL_AUTH_PLAIN:
-
+        if (!(pscf->auth_methods & NGX_MAIL_AUTH_PLAIN_ENABLED)) {
+            return NGX_MAIL_PARSE_INVALID_AUTH_MECH;
+        }
         ngx_str_set(&s->out, pop3_next);
         s->mail_state = ngx_pop3_auth_plain;
 
-        return NGX_OK;
+        return NGX_MAIL_AUTH_ARGUMENT;
+    
+    case NGX_MAIL_AUTH_PLAIN_IR:
+        if (!(pscf->auth_methods & NGX_MAIL_AUTH_PLAIN_ENABLED)) {
+            return NGX_MAIL_PARSE_INVALID_AUTH_MECH;
+        }
+        return ngx_mail_auth_plain(s, c, 1);
+
+    case NGX_MAIL_AUTH_GSSAPI:
+        if( !(pscf->auth_methods & NGX_MAIL_AUTH_GSSAPI_ENABLED)) {
+            return NGX_MAIL_PARSE_INVALID_AUTH_MECH;
+        }
+        ngx_str_set(&s->out, pop3_gssapi_next);
+        s->mail_state = ngx_pop3_auth_gssapi;
+        return NGX_MAIL_AUTH_ARGUMENT;
+
+    case NGX_MAIL_AUTH_GSSAPI_IR:
+
+        if (!(pscf->auth_methods & NGX_MAIL_AUTH_GSSAPI_ENABLED)) {
+            return NGX_MAIL_PARSE_INVALID_AUTH_MECH;
+        }
+        s->mail_state = ngx_pop3_auth_gssapi;
+        ngx_str_t output;
+        ngx_str_set(&output, "");
+        int res = ngx_mail_auth_gssapi(s, c, &output);
+        if(res == NGX_MAIL_AUTH_ARGUMENT) {
+            s->out = output;
+            return NGX_MAIL_AUTH_ARGUMENT;
+        } else {
+            return res;
+        }
 
     case NGX_MAIL_AUTH_CRAM_MD5:
 
         if (!(pscf->auth_methods & NGX_MAIL_AUTH_CRAM_MD5_ENABLED)) {
-            return NGX_MAIL_PARSE_INVALID_COMMAND;
+            return NGX_MAIL_PARSE_INVALID_AUTH_MECH;
         }
 
         if (ngx_mail_auth_cram_md5_salt(s, c, "+ ", 2) == NGX_OK) {
             s->mail_state = ngx_pop3_auth_cram_md5;
-            return NGX_OK;
+            return NGX_MAIL_AUTH_ARGUMENT;
         }
 
         return NGX_ERROR;
+
+    default:
+    	break;
     }
 
     return rc;
diff -ur nginx-1.7.1/src/mail/ngx_mail_pop3_module.c nginx-1.7.1-zimbra/src/mail/ngx_mail_pop3_module.c
--- nginx-1.7.1/src/mail/ngx_mail_pop3_module.c	2014-05-27 06:58:10.000000000 -0700
+++ nginx-1.7.1-zimbra/src/mail/ngx_mail_pop3_module.c	2014-07-23 12:24:10.000000000 -0700
@@ -4,6 +4,10 @@
  * Copyright (C) Nginx, Inc.
  */
 
+/*
+ * Portions Copyright (c) Zimbra Software, LLC. [1998-2011]. All Rights Reserved.
+ */
+
 
 #include <ngx_config.h>
 #include <ngx_core.h>
@@ -16,6 +20,7 @@
 static char *ngx_mail_pop3_merge_srv_conf(ngx_conf_t *cf, void *parent,
     void *child);
 
+static ngx_str_t default_pop3_greeting = ngx_string("+OK POP3 ready");
 
 static ngx_str_t  ngx_mail_pop3_default_capabilities[] = {
     ngx_string("TOP"),
@@ -28,7 +33,9 @@
 static ngx_conf_bitmask_t  ngx_mail_pop3_auth_methods[] = {
     { ngx_string("plain"), NGX_MAIL_AUTH_PLAIN_ENABLED },
     { ngx_string("apop"), NGX_MAIL_AUTH_APOP_ENABLED },
+    { ngx_string("login"), NGX_MAIL_AUTH_LOGIN_ENABLED },
     { ngx_string("cram-md5"), NGX_MAIL_AUTH_CRAM_MD5_ENABLED },
+    { ngx_string("gssapi"), NGX_MAIL_AUTH_GSSAPI_ENABLED },
     { ngx_null_string, 0 }
 };
 
@@ -58,12 +65,20 @@
     ngx_mail_pop3_parse_command,
     ngx_mail_pop3_auth_state,
 
-    ngx_string("-ERR internal server error" CRLF)
+    ngx_string("-ERR internal server error" CRLF),
+    ngx_string("")
 };
 
 
 static ngx_command_t  ngx_mail_pop3_commands[] = {
 
+    { ngx_string("pop3_client_buffer"),
+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_size_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_pop3_srv_conf_t, client_buffer_size),
+      NULL },
+
     { ngx_string("pop3_capabilities"),
       NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_1MORE,
       ngx_mail_capabilities,
@@ -78,6 +93,13 @@
       offsetof(ngx_mail_pop3_srv_conf_t, auth_methods),
       &ngx_mail_pop3_auth_methods },
 
+    { ngx_string("pop3_greeting"),
+      NGX_MAIL_MAIN_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_pop3_srv_conf_t, greeting),
+      NULL },
+
       ngx_null_command
 };
 
@@ -119,6 +141,8 @@
         return NULL;
     }
 
+    pscf->client_buffer_size = NGX_CONF_UNSET_SIZE;
+    
     if (ngx_array_init(&pscf->capabilities, cf->pool, 4, sizeof(ngx_str_t))
         != NGX_OK)
     {
@@ -135,15 +159,25 @@
     ngx_mail_pop3_srv_conf_t *prev = parent;
     ngx_mail_pop3_srv_conf_t *conf = child;
 
-    u_char      *p;
-    size_t       size, stls_only_size;
+    u_char       *p, *p1, *p2, *p3;
+    size_t       s1, s2, s3;
     ngx_str_t   *c, *d;
     ngx_uint_t   i;
 
+    ngx_conf_merge_size_value(conf->client_buffer_size,
+                              prev->client_buffer_size,
+                              (size_t) 4*ngx_pagesize);
+
     ngx_conf_merge_bitmask_value(conf->auth_methods,
                                  prev->auth_methods,
-                                 (NGX_CONF_BITMASK_SET
-                                  |NGX_MAIL_AUTH_PLAIN_ENABLED));
+                                 NGX_CONF_BITMASK_SET);
+
+
+    ngx_conf_merge_str_value(conf->greeting, prev->greeting,"");
+
+    if (conf->greeting.len == 0) {
+        conf->greeting = default_pop3_greeting;
+    }
 
     if (conf->capabilities.nelts == 0) {
         conf->capabilities = prev->capabilities;
@@ -161,74 +195,108 @@
         }
     }
 
-    size = sizeof("+OK Capability list follows" CRLF) - 1
-           + sizeof("." CRLF) - 1;
-
-    stls_only_size = size + sizeof("STLS" CRLF) - 1;
+    s1 = sizeof("+OK Capability list follows" CRLF) - 1
+         + sizeof("." CRLF)-1;
+    if (conf->auth_methods &
+        (NGX_MAIL_AUTH_PLAIN_ENABLED | NGX_MAIL_AUTH_GSSAPI_ENABLED))
+         s1 += sizeof("SASL" CRLF)-1;
+    s2 = s1;
+    s3 = s1;
 
     c = conf->capabilities.elts;
-    for (i = 0; i < conf->capabilities.nelts; i++) {
-        size += c[i].len + sizeof(CRLF) - 1;
-
-        if (ngx_strcasecmp(c[i].data, (u_char *) "USER") == 0) {
-            continue;
+    for (i=0; i<conf->capabilities.nelts; ++i)
+    {
+        s1 += c[i].len + sizeof (CRLF)-1;
+        s2 += c[i].len + sizeof (CRLF)-1;
+        if (ngx_strcasecmp(c[i].data, (u_char *) "USER") != 0) {
+            s3 += c[i].len + sizeof (CRLF)-1;
         }
+    }
 
-        stls_only_size += c[i].len + sizeof(CRLF) - 1;
+    if (conf->auth_methods & NGX_MAIL_AUTH_PLAIN_ENABLED) {
+        s1 += sizeof(" PLAIN") - 1;
+        s2 += sizeof(" PLAIN") - 1;
+        s3 += sizeof(" PLAIN") - 1;
+    }
+    if (conf->auth_methods & NGX_MAIL_AUTH_GSSAPI_ENABLED) {
+        s1 += sizeof(" GSSAPI") - 1;
+        s2 += sizeof(" GSSAPI") - 1;
+        s3 += sizeof(" GSSAPI") - 1;
     }
 
-    if (conf->auth_methods & NGX_MAIL_AUTH_CRAM_MD5_ENABLED) {
-        size += sizeof("SASL LOGIN PLAIN CRAM-MD5" CRLF) - 1;
+    s2 += sizeof("STLS" CRLF) - 1;
+    s3 += sizeof("STLS" CRLF) - 1;
 
-    } else {
-        size += sizeof("SASL LOGIN PLAIN" CRLF) - 1;
+    p1 = ngx_pnalloc(cf->pool,s1);
+    if (p1 == NULL) {
+        return NGX_CONF_ERROR;
     }
-
-    p = ngx_pnalloc(cf->pool, size);
-    if (p == NULL) {
+    p2 = ngx_palloc(cf->pool,s2);
+    if (p2 == NULL) {
         return NGX_CONF_ERROR;
     }
-
-    conf->capability.len = size;
-    conf->capability.data = p;
-
-    p = ngx_cpymem(p, "+OK Capability list follows" CRLF,
-                   sizeof("+OK Capability list follows" CRLF) - 1);
-
-    for (i = 0; i < conf->capabilities.nelts; i++) {
-        p = ngx_cpymem(p, c[i].data, c[i].len);
-        *p++ = CR; *p++ = LF;
+    p3 = ngx_pnalloc(cf->pool,s3);
+    if (p3 == NULL) {
+        return NGX_CONF_ERROR;
     }
 
-    if (conf->auth_methods & NGX_MAIL_AUTH_CRAM_MD5_ENABLED) {
-        p = ngx_cpymem(p, "SASL LOGIN PLAIN CRAM-MD5" CRLF,
-                       sizeof("SASL LOGIN PLAIN CRAM-MD5" CRLF) - 1);
+    conf->capability.len = s1;
+    conf->capability.data = p1;
+    conf->starttls_capability.len = s2;
+    conf->starttls_capability.data = p2;
+    conf->starttls_only_capability.len = s3;
+    conf->starttls_only_capability.data = p3;
+
+    p1 = ngx_cpymem(p1, "+OK Capability list follows" CRLF,
+                        sizeof("+OK Capability list follows" CRLF) - 1);
+    p2 = ngx_cpymem(p2, "+OK Capability list follows" CRLF,
+                        sizeof("+OK Capability list follows" CRLF) - 1);
+    p3 = ngx_cpymem(p3, "+OK Capability list follows" CRLF,
+                        sizeof("+OK Capability list follows" CRLF) - 1);
 
-    } else {
-        p = ngx_cpymem(p, "SASL LOGIN PLAIN" CRLF,
-                       sizeof("SASL LOGIN PLAIN" CRLF) - 1);
+    c = conf->capabilities.elts;
+    for (i = 0; i < conf->capabilities.nelts; ++i)
+    {
+        p1 = ngx_cpymem(p1,c[i].data,c[i].len);
+        p2 = ngx_cpymem(p2,c[i].data,c[i].len);
+        *p1++ = CR; *p1++ = LF;
+        *p2++ = CR; *p2++ = LF;
+        if (ngx_strcasecmp(c[i].data, (u_char *) "USER") != 0) {
+            p3 = ngx_cpymem(p3,c[i].data,c[i].len);
+            *p3++ = CR; *p3++ = LF;
+        }
     }
 
-    *p++ = '.'; *p++ = CR; *p = LF;
-
-
-    size += sizeof("STLS" CRLF) - 1;
+    if (conf->auth_methods &
+        (NGX_MAIL_AUTH_PLAIN_ENABLED | NGX_MAIL_AUTH_GSSAPI_ENABLED)) {
+        p1 = ngx_cpymem(p1,"SASL",sizeof("SASL") - 1);
+        p2 = ngx_cpymem(p2,"SASL",sizeof("SASL") - 1);
+        p3 = ngx_cpymem(p3,"SASL",sizeof("SASL") - 1);
+
+        if (conf->auth_methods & NGX_MAIL_AUTH_PLAIN_ENABLED) {
+            p1 = ngx_cpymem(p1," PLAIN",sizeof(" PLAIN") - 1);
+            p2 = ngx_cpymem(p2," PLAIN",sizeof(" PLAIN") - 1);
+            p3 = ngx_cpymem(p3," PLAIN",sizeof(" PLAIN") - 1);
+        }
+        if (conf->auth_methods & NGX_MAIL_AUTH_GSSAPI_ENABLED) {
+            p1 = ngx_cpymem(p1," GSSAPI",sizeof(" GSSAPI") - 1);
+            p2 = ngx_cpymem(p2," GSSAPI",sizeof(" GSSAPI") - 1);
+            p3 = ngx_cpymem(p3," GSSAPI",sizeof(" GSSAPI") - 1);
+        }
 
-    p = ngx_pnalloc(cf->pool, size);
-    if (p == NULL) {
-        return NGX_CONF_ERROR;
+        *p1++ = CR; *p1++ = LF;
+        *p2++ = CR; *p2++ = LF;
+        *p3++ = CR; *p3++ = LF;
     }
 
-    conf->starttls_capability.len = size;
-    conf->starttls_capability.data = p;
-
-    p = ngx_cpymem(p, conf->capability.data,
-                   conf->capability.len - (sizeof("." CRLF) - 1));
-
-    p = ngx_cpymem(p, "STLS" CRLF, sizeof("STLS" CRLF) - 1);
-    *p++ = '.'; *p++ = CR; *p = LF;
+    p2 = ngx_cpymem(p2,"STLS" CRLF, sizeof("STLS" CRLF)-1);
+    p3 = ngx_cpymem(p3,"STLS" CRLF, sizeof("STLS" CRLF)-1);
 
+    *p1++ = '.'; *p1++ = CR; *p1++ = LF;
+    *p2++ = '.'; *p2++ = CR; *p2++ = LF;
+    *p3++ = '.'; *p3++ = CR; *p3++ = LF;
 
+    /* not required */
     if (conf->auth_methods & NGX_MAIL_AUTH_CRAM_MD5_ENABLED) {
         conf->auth_capability = ngx_mail_pop3_auth_cram_md5_capability;
 
@@ -236,29 +304,15 @@
         conf->auth_capability = ngx_mail_pop3_auth_plain_capability;
     }
 
-
-    p = ngx_pnalloc(cf->pool, stls_only_size);
+    p = ngx_pnalloc(cf->pool,conf->greeting.len + 2);
     if (p == NULL) {
         return NGX_CONF_ERROR;
     }
 
-    conf->starttls_only_capability.len = stls_only_size;
-    conf->starttls_only_capability.data = p;
-
-    p = ngx_cpymem(p, "+OK Capability list follows" CRLF,
-                   sizeof("+OK Capability list follows" CRLF) - 1);
-
-    for (i = 0; i < conf->capabilities.nelts; i++) {
-        if (ngx_strcasecmp(c[i].data, (u_char *) "USER") == 0) {
-            continue;
-        }
-
-        p = ngx_cpymem(p, c[i].data, c[i].len);
-        *p++ = CR; *p++ = LF;
-    }
-
-    p = ngx_cpymem(p, "STLS" CRLF, sizeof("STLS" CRLF) - 1);
-    *p++ = '.'; *p++ = CR; *p = LF;
+    ngx_memcpy(p, conf->greeting.data, conf->greeting.len);
+    ngx_memcpy(p + conf->greeting.len, CRLF, sizeof(CRLF) - 1);
+    conf->greeting.data = p;
+    conf->greeting.len += 2;
 
     return NGX_CONF_OK;
 }
diff -ur nginx-1.7.1/src/mail/ngx_mail_pop3_module.h nginx-1.7.1-zimbra/src/mail/ngx_mail_pop3_module.h
--- nginx-1.7.1/src/mail/ngx_mail_pop3_module.h	2014-05-27 06:58:10.000000000 -0700
+++ nginx-1.7.1-zimbra/src/mail/ngx_mail_pop3_module.h	2014-07-23 12:24:10.000000000 -0700
@@ -15,6 +15,8 @@
 
 
 typedef struct {
+    size_t       client_buffer_size;
+
     ngx_str_t    capability;
     ngx_str_t    starttls_capability;
     ngx_str_t    starttls_only_capability;
@@ -23,6 +25,8 @@
     ngx_uint_t   auth_methods;
 
     ngx_array_t  capabilities;
+
+    ngx_str_t    greeting;
 } ngx_mail_pop3_srv_conf_t;
 
 
diff -ur nginx-1.7.1/src/mail/ngx_mail_proxy_module.c nginx-1.7.1-zimbra/src/mail/ngx_mail_proxy_module.c
--- nginx-1.7.1/src/mail/ngx_mail_proxy_module.c	2014-05-27 06:58:10.000000000 -0700
+++ nginx-1.7.1-zimbra/src/mail/ngx_mail_proxy_module.c	2014-07-29 11:52:01.000000000 -0700
@@ -4,19 +4,35 @@
  * Copyright (C) Nginx, Inc.
  */
 
+/*
+ * Portions Copyright (c) Zimbra Software, LLC. [1998-2011]. All Rights Reserved.
+ */
 
+#include <nginx.h>
 #include <ngx_config.h>
 #include <ngx_core.h>
 #include <ngx_event.h>
 #include <ngx_event_connect.h>
 #include <ngx_mail.h>
+#include <ngx_mail_throttle_module.h>
+#include <ngx_mail_pop3_module.h>
+#include <ngx_mail_imap_module.h>
+#include <ngx_mail_smtp_module.h>
+#include <ngx_zm_lookup.h>
 
+extern ngx_module_t ngx_mail_auth_http_module;
 
 typedef struct {
     ngx_flag_t  enable;
     ngx_flag_t  pass_error_message;
+    ngx_flag_t  issue_pop3_xoip;
+    ngx_flag_t  issue_imap_id;
     ngx_flag_t  xclient;
+    ngx_flag_t  proxy_ssl;
+    ngx_flag_t  proxy_ssl_session_reuse;
+    ngx_ssl_t  *ssl;
     size_t      buffer_size;
+    ngx_msec_t  ctimeout;
     ngx_msec_t  timeout;
 } ngx_mail_proxy_conf_t;
 
@@ -36,6 +52,31 @@
 static char *ngx_mail_proxy_merge_conf(ngx_conf_t *cf, void *parent,
     void *child);
 
+#if (NGX_MAIL_SSL)
+static char *ngx_mail_proxy_ssl(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+static void ngx_mail_proxy_ssl_init_connection(ngx_mail_session_t *s,
+        ngx_connection_t *c);
+static void ngx_mail_proxy_ssl_handshake(ngx_connection_t *c);
+/** TODO suport ssl session reuse
+static void ngx_mail_proxy_set_session(ngx_peer_connection_t *pc);
+static void ngx_mail_proxy_save_session(ngx_peer_connection_t *pc);
+*/
+#endif
+
+/* throttle */
+static void ngx_mail_proxy_throttle_imap(ngx_event_t *rev);
+static void ngx_mail_proxy_allow_imap(throttle_callback_t *callback);
+static void ngx_mail_proxy_choke_imap(throttle_callback_t *callback);
+static void ngx_mail_proxy_throttle_pop3(ngx_event_t *rev);
+static void ngx_mail_proxy_allow_pop3(throttle_callback_t *callback);
+static void ngx_mail_proxy_choke_pop3(throttle_callback_t *callback);
+static void ngx_mail_proxy_choke_session(ngx_mail_session_t *s);
+
+/* utility */
+static ngx_str_t ngx_imap_quote_string(ngx_pool_t *pool, ngx_str_t *u);
+static void ngx_mail_proxy_auth_sleep_handler (ngx_event_t *rev);
+
 
 static ngx_command_t  ngx_mail_proxy_commands[] = {
 
@@ -53,6 +94,13 @@
       offsetof(ngx_mail_proxy_conf_t, buffer_size),
       NULL },
 
+    { ngx_string("proxy_ctimeout"),
+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_msec_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_proxy_conf_t, ctimeout),
+      NULL },
+
     { ngx_string("proxy_timeout"),
       NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,
       ngx_conf_set_msec_slot,
@@ -66,6 +114,20 @@
       NGX_MAIL_SRV_CONF_OFFSET,
       offsetof(ngx_mail_proxy_conf_t, pass_error_message),
       NULL },
+      
+    { ngx_string("proxy_issue_pop3_xoip"),
+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_flag_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_proxy_conf_t, issue_pop3_xoip),
+      NULL },
+
+    { ngx_string("proxy_issue_imap_id"),
+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_flag_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_proxy_conf_t, issue_imap_id),
+      NULL },
 
     { ngx_string("xclient"),
       NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_FLAG,
@@ -74,6 +136,23 @@
       offsetof(ngx_mail_proxy_conf_t, xclient),
       NULL },
 
+#if (NGX_MAIL_SSL)
+
+    { ngx_string("proxy_ssl"),
+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_FLAG,
+      ngx_mail_proxy_ssl,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_proxy_conf_t, proxy_ssl),
+      NULL },
+
+    { ngx_string("proxy_ssl_session_reuse"),
+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_FLAG,
+      ngx_conf_set_flag_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_proxy_conf_t, proxy_ssl_session_reuse),
+      NULL },
+#endif
+
       ngx_null_command
 };
 
@@ -105,8 +184,12 @@
 };
 
 
+static u_char  pop3_authplain[] = "AUTH PLAIN" CRLF;
+static u_char  pop3_authxzimbra[] = "AUTH X-ZIMBRA" CRLF;
 static u_char  smtp_auth_ok[] = "235 2.0.0 OK" CRLF;
-
+static u_char  imap_login_no[] = "NO LOGIN failed" CRLF;
+static u_char  imap_auth_no[] = "NO AUTHENTICATE failed" CRLF;
+static u_char  imap_no[] = "NO" CRLF;
 
 void
 ngx_mail_proxy_init(ngx_mail_session_t *s, ngx_addr_t *peer)
@@ -155,7 +238,9 @@
         return;
     }
 
-    ngx_add_timer(p->upstream.connection->read, cscf->timeout);
+    pcf = ngx_mail_get_module_srv_conf(s, ngx_mail_proxy_module);
+
+    ngx_add_timer(p->upstream.connection->read, pcf->ctimeout);
 
     p->upstream.connection->data = s;
     p->upstream.connection->pool = s->connection->pool;
@@ -163,8 +248,6 @@
     s->connection->read->handler = ngx_mail_proxy_block_read;
     p->upstream.connection->write->handler = ngx_mail_proxy_dummy_handler;
 
-    pcf = ngx_mail_get_module_srv_conf(s, ngx_mail_proxy_module);
-
     s->proxy->buffer = ngx_create_temp_buf(s->connection->pool,
                                            pcf->buffer_size);
     if (s->proxy->buffer == NULL) {
@@ -174,6 +257,16 @@
 
     s->out.len = 0;
 
+/* bug 32683, ssl support on mail proxy connection */
+#if (NGX_MAIL_SSL)
+
+    if (pcf->proxy_ssl && p->upstream.connection->ssl == NULL) {
+        ngx_mail_proxy_ssl_init_connection(s, p->upstream.connection);
+        return;
+    }
+
+#endif
+
     switch (s->protocol) {
 
     case NGX_MAIL_POP3_PROTOCOL:
@@ -216,16 +309,28 @@
 {
     u_char                 *p;
     ngx_int_t               rc;
+    int                     family;
     ngx_str_t               line;
+    size_t                  len;
     ngx_connection_t       *c;
     ngx_mail_session_t     *s;
     ngx_mail_proxy_conf_t  *pcf;
+    struct sockaddr_in     *sin;
+
+#if (NGX_HAVE_INET6)
+    struct sockaddr_in6    *sin6;
+#endif
+
+    ngx_mail_core_srv_conf_t   *cscf;
+    ngx_str_t                   ap, ap64, tmp;
 
     ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0,
                    "mail proxy pop3 auth handler");
 
     c = rev->data;
     s = c->data;
+    pcf = ngx_mail_get_module_srv_conf(s, ngx_mail_proxy_module);
+    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);
 
     if (rev->timedout) {
         ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT,
@@ -235,36 +340,165 @@
         return;
     }
 
-    rc = ngx_mail_proxy_read_response(s, 0);
+    rc = ngx_mail_proxy_read_response(s, s->mail_state);
 
     if (rc == NGX_AGAIN) {
         return;
     }
 
     if (rc == NGX_ERROR) {
-        ngx_mail_proxy_upstream_error(s);
-        return;
+        if (s->mail_state == ngx_pop3_passwd ||
+            s->mail_state == ngx_pop3_auth_plain_response
+           )
+        {
+            if(s->proxy->upstream.connection->read->timer_set) {
+                ngx_del_timer(s->proxy->upstream.connection->read);
+            }
+
+            ngx_add_timer(s->connection->read,cscf->auth_wait_intvl);
+            s->connection->read->handler = ngx_mail_proxy_auth_sleep_handler;
+            return;
+        }
+        else
+        {
+            ngx_mail_proxy_upstream_error(s);
+            return;
+        }
+    }
+
+    if (s->mail_state == ngx_pop3_start)
+    {
+        // bug 23349 -- conditionally (not always) issue pop3 xoip command
+        if (pcf->issue_pop3_xoip == 0) {
+            s->mail_state = ngx_pop3_xoip;
+        }
     }
 
     switch (s->mail_state) {
 
     case ngx_pop3_start:
-        ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0, "mail proxy send user");
+        s->connection->log->action = 
+            "sending POP3 XOIP command to upstream";
 
-        s->connection->log->action = "sending user name to upstream";
+        /* Bug 13325 - The upstream server needs to record the IP address of
+           the downstream client that connected. For this, the Zimbra server
+           has been modified to support the XOIP command that will allow 
+           the proxy to pass the IP address of the downstream client. Both
+           ipv4 and ipv6 (bug 56383) has been supported
+         */
+        family = s->connection->sockaddr->sa_family;
+        if (family == AF_INET) {
+            len = NGX_INET_ADDRSTRLEN;
+            sin = (struct sockaddr_in *) s->connection->sockaddr;
+
+#if (NGX_HAVE_INET6)
+        } else { /* AF_INET6 */
+            len = NGX_INET6_ADDRSTRLEN;
+            sin6 = (struct sockaddr_in6 *) s->connection->sockaddr;
+#endif
+
+        }
+
+        line.len = sizeof ("XOIP ") -1 +
+                len +
+                sizeof (CRLF) - 1;
+
+        line.data = ngx_palloc(c->pool, line.len);
 
-        line.len = sizeof("USER ")  - 1 + s->login.len + 2;
-        line.data = ngx_pnalloc(c->pool, line.len);
         if (line.data == NULL) {
             ngx_mail_proxy_internal_server_error(s);
             return;
         }
 
-        p = ngx_cpymem(line.data, "USER ", sizeof("USER ") - 1);
-        p = ngx_cpymem(p, s->login.data, s->login.len);
-        *p++ = CR; *p = LF;
+        p = ngx_sprintf (line.data, "XOIP ");
+        tmp.data = p;
+
+        if (family == AF_INET) {
+            len = ngx_inet_ntop (family, &(sin->sin_addr.s_addr), p,
+                    line.data + line.len - p);
+
+#if (NGX_HAVE_INET6)
+        } else { /* AF_INET6 */
+            len = ngx_inet_ntop (family, &(sin6->sin6_addr.s6_addr),
+                    p, line.data + line.len - p);
+#endif
+
+        }
+
+        p += len;
+
+        tmp.len = p - tmp.data;
+
+        *p++ = CR;
+        *p++ = LF;
+
+        line.len = p - line.data;
+
+        ngx_log_debug1(NGX_LOG_DEBUG_MAIL, rev->log, 0,
+            "sending POP3 XOIP command (XOIP %V)",
+            &tmp);
+
+        s->mail_state = ngx_pop3_xoip;
+
+        break;
+
+    case ngx_pop3_xoip:
+        if (!s->usedauth && (s->auth_method == NGX_MAIL_AUTH_PLAIN
+                || s->auth_method == NGX_MAIL_AUTH_PLAIN_IR))
+        {
+            /* If auth plain was used, but no authz, then we must blank out
+               login+zlogin, and use dusr+zusr in authc to upstream
+             */
+            s->dusr = s->qlogin;
+            s->zusr = s->zlogin;
+            s->qlogin.data = (u_char*)"";
+            s->qlogin.len = 0;
+            s->zlogin.data = (u_char*)"";
+            s->zlogin.len = 0;
+            s->usedauth = 1;
+        }
+
+        if (!s->usedauth)
+        {
+            ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0,
+                "mail proxy send user");
+
+            s->connection->log->action = "sending user name to upstream";
+
+            line.len = sizeof("USER ")  - 1 + s->qlogin.len + 2;
+            line.data = ngx_palloc(c->pool, line.len);
+            if (line.data == NULL) {
+                ngx_mail_proxy_internal_server_error(s);
+                return;
+            }
+
+            p = ngx_cpymem(line.data, "USER ", sizeof("USER ") - 1);
+            p = ngx_cpymem(p, s->qlogin.data, s->qlogin.len);
+            *p++ = CR; *p = LF;
+
+            s->mail_state = ngx_pop3_user;
+        }
+        else
+        {
+            ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0,
+                    "mail proxy send auth plain");
+
+            if (s->auth_method == NGX_MAIL_AUTH_GSSAPI)
+            {
+                s->connection->log->action = "sending AUTH X-ZIMBRA to upstream";
+                line.len = sizeof(pop3_authxzimbra) -1;
+                line.data = pop3_authxzimbra;
+            }
+            else
+            {
+                s->connection->log->action = "sending AUTH PLAIN to upstream";
+                line.len = sizeof(pop3_authplain) - 1;
+                line.data = pop3_authplain;
+            }
+
+            s->mail_state = ngx_pop3_auth_plain;
+        }
 
-        s->mail_state = ngx_pop3_user;
         break;
 
     case ngx_pop3_user:
@@ -287,21 +521,67 @@
         break;
 
     case ngx_pop3_passwd:
-        s->connection->read->handler = ngx_mail_proxy_handler;
-        s->connection->write->handler = ngx_mail_proxy_handler;
-        rev->handler = ngx_mail_proxy_handler;
-        c->write->handler = ngx_mail_proxy_handler;
+    case ngx_pop3_auth_plain_response:
+        ngx_mail_proxy_throttle_pop3(rev);
+        return;
 
-        pcf = ngx_mail_get_module_srv_conf(s, ngx_mail_proxy_module);
-        ngx_add_timer(s->connection->read, pcf->timeout);
-        ngx_del_timer(c->read);
+    case ngx_pop3_auth_plain:
+        if (s->auth_method == NGX_MAIL_AUTH_GSSAPI) {
+            ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0,
+                "mail proxy send AUTH X-ZIMBRA response");
+            s->connection->log->action = "sending AUTH X-ZIMBRA response to upstream";
+        }
+        else {
+            ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0,
+                "mail proxy send AUTH PLAIN response");
+            s->connection->log->action = "sending AUTH PLAIN response to upstream";
+        }
 
-        c->log->action = NULL;
-        ngx_log_error(NGX_LOG_INFO, c->log, 0, "client logged in");
 
-        ngx_mail_proxy_handler(s->connection->write);
+        ap.len = s->qlogin.len + 1 +
+                 s->dusr.len + 1 +
+                 s->dpasswd.len;
+        ap.data = ngx_palloc (c->pool, ap.len);
 
-        return;
+        if (ap.data == NULL) {
+            ngx_mail_proxy_internal_server_error(s);
+            return;
+        }
+
+        ngx_memcpy (ap.data, s->qlogin.data, s->qlogin.len);
+        ngx_memcpy (ap.data + s->qlogin.len, "\x0", 1);
+        ngx_memcpy (ap.data + s->qlogin.len + 1,
+                    s->dusr.data,
+                    s->dusr.len);
+        ngx_memcpy (ap.data + s->qlogin.len + 1 + s->dusr.len,
+                    "\x0",1);
+        ngx_memcpy (ap.data + s->qlogin.len+1 + s->dusr.len + 1,
+                    s->dpasswd.data,
+                    s->dpasswd.len);
+
+        ap64.len = ngx_base64_encoded_length(ap.len);
+        ap64.data = ngx_palloc(c->pool, ap64.len);
+
+        if (ap64.data == NULL) {
+            ngx_mail_proxy_internal_server_error(s);
+            return;
+        }
+
+        ngx_encode_base64 (&ap64, &ap);
+
+        line.len = ap64.len + sizeof(CRLF) -1;
+        line.data = ngx_palloc (c->pool, line.len);
+
+        if (line.data == NULL) {
+            ngx_mail_proxy_internal_server_error(s);
+            return;
+        }
+
+        ngx_memcpy (line.data, ap64.data, ap64.len);
+        ngx_memcpy (line.data + ap64.len, CRLF, sizeof (CRLF) -1);
+
+        s->mail_state = ngx_pop3_auth_plain_response;
+        break;
 
     default:
 #if (NGX_SUPPRESS_WARN)
@@ -329,16 +609,33 @@
 {
     u_char                 *p;
     ngx_int_t               rc;
-    ngx_str_t               line;
+    ngx_uint_t              family;
+    size_t                  len;
+    ngx_str_t               line, proxy_ip;
     ngx_connection_t       *c;
     ngx_mail_session_t     *s;
     ngx_mail_proxy_conf_t  *pcf;
+    struct sockaddr_in     *sin;
+
+#if (NGX_HAVE_INET6)
+    struct sockaddr_in6        *sin6;
+#endif
+
+    ngx_mail_core_srv_conf_t   *cscf;
+    ngx_mail_imap_srv_conf_t   *iscf;
+    ngx_str_t                   challenge;
+    ngx_str_t                   ql, qp, login, tmp;
+    socklen_t                   socklen;
+    u_char                      sockaddr[NGX_SOCKADDRLEN];
 
     ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0,
                    "mail proxy imap auth handler");
 
     c = rev->data;
     s = c->data;
+    pcf = ngx_mail_get_module_srv_conf(s, ngx_mail_proxy_module);
+    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);
+    iscf = ngx_mail_get_module_srv_conf(s, ngx_mail_imap_module);
 
     if (rev->timedout) {
         ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT,
@@ -354,32 +651,268 @@
         return;
     }
 
-    if (rc == NGX_ERROR) {
-        ngx_mail_proxy_upstream_error(s);
+    if (rc == NGX_ABORT) {
+        /* NGX_ABORT is borrowed to indicate nginx should send
+         * something coming from upstream directly.
+         */
+        if (s->connection->send(s->connection, s->out.data, s->out.len) <
+                (ssize_t) s->out.len) {
+            ngx_mail_proxy_internal_server_error(s);
+            return;
+        }
+        s->proxy->buffer->pos = s->proxy->buffer->start;
+        s->proxy->buffer->last = s->proxy->buffer->start;
         return;
     }
 
+    if (rc == NGX_ERROR) {
+        if (s->mail_state == ngx_imap_passwd ||
+            s->mail_state == ngx_imap_auth_plain_ir
+           )
+        {
+            if(s->proxy->upstream.connection->read->timer_set) {
+                ngx_del_timer(s->proxy->upstream.connection->read);
+            }
+
+            ngx_add_timer(s->connection->read,cscf->auth_wait_intvl);
+            s->connection->read->handler = ngx_mail_proxy_auth_sleep_handler;
+            return;
+        }
+        else
+        {
+            ngx_mail_proxy_upstream_error(s);
+            return;
+        }
+    }
+
+    if (s->mail_state == ngx_imap_start)
+    {
+        // bug 23349 -- conditionally (not always) issue imap id command
+        if (pcf->issue_imap_id == 0) {
+            s->mail_state = ngx_imap_id;
+        }
+    }
+
+
     switch (s->mail_state) {
 
     case ngx_imap_start:
         ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0,
-                       "mail proxy send login");
+                       "mail proxy send id");
+                       
+        s->connection->log->action = 
+            "sending IMAP ID extension command to upstream";
+
+        /* Bug 13325 - The upstream server needs to record the IP of the
+           original downstream client that connected, not just the proxy's IP
+           To pass on the information about the downstream client, we use the
+           IMAP ID extension command (rfc 2971)
+
+           Currently both ipv4 and ipv6 (bug 56383) are supported
+         */
+        family = s->connection->sockaddr->sa_family;
+        if (family == AF_INET) {
+            len = NGX_INET_ADDRSTRLEN;
+            sin = (struct sockaddr_in *) s->connection->sockaddr;
 
-        s->connection->log->action = "sending LOGIN command to upstream";
+#if (NGX_HAVE_INET6)
+        } else { /* AF_INET6 */
+            len = NGX_INET6_ADDRSTRLEN;
+            sin6 = (struct sockaddr_in6 *) s->connection->sockaddr;
+#endif
+
+        }
+
+        line.len = s->tag.len + 1 /* for space */ +
+                sizeof ("ID (\"X-ORIGINATING-IP\" \"") - 1 +
+                len +
+                sizeof ("\" \"name\" \"") - 1 +
+                iscf->ua_name.len +
+                sizeof("\" \"version\" \"") - 1 +
+                iscf->ua_version.len +
+                sizeof ("\" \"X-VIA\" \"(" NGINX_VER ")\")"CRLF) - 1;
+        ngx_memzero(sockaddr, NGX_SOCKADDRLEN);
+        socklen = NGX_SOCKADDRLEN;
+        if(getsockname(s->connection->fd, (struct sockaddr*)sockaddr, &socklen) < 0) {
+            ngx_log_error(NGX_LOG_WARN, s->connection->log, errno, "can't get proxy's IP address");
+        }
+
+        if(((struct sockaddr *)sockaddr)->sa_family == AF_INET) {
+            proxy_ip.len = NGX_INET_ADDRSTRLEN;
+        } else {
+            proxy_ip.len = NGX_INET6_ADDRSTRLEN;
+        }
+        proxy_ip.data = ngx_palloc(c->pool, proxy_ip.len);
+        proxy_ip.len = ngx_sock_ntop((struct sockaddr*)sockaddr, socklen, proxy_ip.data, proxy_ip.len, 0);
+        line.len += proxy_ip.len;
+
+        if (s->id_name.len > 0) {
+            line.len += (s->id_name.len + sizeof(",") - 1);
+            if (s->id_version.len > 0) {
+                line.len += (s->id_version.len + sizeof("/") - 1);
+            }
+        }
+
+        line.data = ngx_palloc(c->pool, line.len);
 
-        line.len = s->tag.len + sizeof("LOGIN ") - 1
-                   + 1 + NGX_SIZE_T_LEN + 1 + 2;
-        line.data = ngx_pnalloc(c->pool, line.len);
         if (line.data == NULL) {
             ngx_mail_proxy_internal_server_error(s);
             return;
         }
 
-        line.len = ngx_sprintf(line.data, "%VLOGIN {%uz}" CRLF,
-                               &s->tag, s->login.len)
-                   - line.data;
+        p = ngx_sprintf (line.data, "%V ID (\"X-ORIGINATING-IP\" \"", &s->tag);
+        tmp.data = p;
+
+        if (family == AF_INET) {
+            len = ngx_inet_ntop (family, &(sin->sin_addr.s_addr), p,
+                    line.data + line.len - p);
+#if (NGX_HAVE_INET6)
+        } else { /* AF_INET6 */
+            len = ngx_inet_ntop (family, &(sin6->sin6_addr.s6_addr),
+                    p, line.data + line.len - p);
+#endif
+        }
+
+        p += len;
+        tmp.len = p - tmp.data;
+
+        p = ngx_sprintf(p, "\" \"name\" \"%V\" \"version\" \"%V\" \"X-VIA\" \"",
+                        &iscf->ua_name, &iscf->ua_version);
+        if (s->id_name.len > 0) {
+            p = ngx_cpymem(p, s->id_name.data, s->id_name.len);
+            if (s->id_version.len > 0) {
+                *p++ = '/';
+                p = ngx_cpymem(p, s->id_version.data, s->id_version.len);
+            }
+            *p++ = ',';
+        }
+        p = ngx_sprintf(p, "%V(" NGINX_VER ")\")"CRLF, &proxy_ip);
+
+        line.len = p - line.data;
+
+        ngx_log_debug1(NGX_LOG_DEBUG_MAIL, rev->log, 0,
+                "sending IMAP ID command %V",
+                &line);
+
+        s->mail_state = ngx_imap_id;
 
-        s->mail_state = ngx_imap_login;
+        break;
+
+    case ngx_imap_id:
+        /* If the downstream client has logged in with a sasl mechanism 
+           that does not use clear-text passwords, we do not have the 
+           end user credentials to log in to the upstream server, therefore
+           in this case, we need to log in with the master username and 
+           master password, using auth plain to the upstream server
+         */
+
+        if (!s->usedauth && (s->auth_method == NGX_MAIL_AUTH_PLAIN
+                || s->auth_method == NGX_MAIL_AUTH_PLAIN_IR)) {
+            /* If auth plain was used, but no authz, then we must blank out
+               login+zlogin, and use dusr+zusr in authc to upstream
+             */
+            s->dusr = s->qlogin;
+            s->zusr = s->zlogin;
+            s->qlogin.data = (u_char*)"";
+            s->qlogin.len = 0;
+            s->zlogin.data = (u_char*)"";
+            s->zlogin.len = 0;
+            s->usedauth = 1;
+        }
+
+        if (!s->usedauth)
+        {
+            ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0,
+                   "no delegated auth, login to upstream using LOGIN");
+
+            s->connection->log->action = "sending LOGIN command to upstream";
+
+            /* LOGIN with literal or quoted strings (imap_literalauth) */
+            if (iscf->literalauth)
+            {
+                line.len = s->tag.len + 1 + sizeof("LOGIN ") - 1
+                           + 1 + NGX_SIZE_T_LEN + 1 + 2;
+                line.data = ngx_palloc(c->pool, line.len);
+                if (line.data == NULL) {
+                    ngx_mail_proxy_internal_server_error(s);
+                    return;
+                }
+
+                line.len = ngx_sprintf(line.data, "%V LOGIN {%uz}" CRLF,
+                                       &s->tag, s->qlogin.len + s->zlogin.len)
+                           - line.data;
+
+                s->mail_state = ngx_imap_login;
+            }
+            else
+            {
+                /* merge back zimbra extensions (/tb|/wm|/ni), if any */
+
+                login.data = ngx_palloc(c->pool, s->qlogin.len + s->zlogin.len);
+                if (login.data == NULL) {
+                    login = s->qlogin;
+                } else {
+                    login.len = s->qlogin.len + s->zlogin.len;
+                    ngx_memcpy(login.data, s->qlogin.data, s->qlogin.len);
+                    ngx_memcpy(login.data + s->qlogin.len, s->zlogin.data,
+                               s->zlogin.len);
+                }
+                ql = ngx_imap_quote_string(c->pool, &login);
+                qp = ngx_imap_quote_string(c->pool, &s->passwd);
+
+                line.len = s->tag.len + 1 /* for space */ + sizeof("LOGIN ") - 1 +
+                           ql.len + 
+                           sizeof(" ") - 1 +
+                           qp.len +
+                           sizeof(CRLF) - 1;
+
+                line.data = ngx_palloc(c->pool,line.len);
+                if (line.data == NULL) {
+                    ngx_mail_proxy_internal_server_error(s);
+                    return;
+                }
+
+                ngx_sprintf(line.data,"%V LOGIN %V %V" CRLF, &s->tag, &ql, &qp);
+
+                s->mail_state = ngx_imap_passwd;
+            }
+        }
+        else
+        {
+            ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0,
+                "Using delegated auth to log in to upstream");
+
+            if (s->auth_method == NGX_MAIL_AUTH_GSSAPI)
+            {
+                s->connection->log->action = "sending AUTHENTICATE X-ZIMBRA to upstream";
+
+                line.len = s->tag.len + 1 /* for space */ + sizeof ("AUTHENTICATE X-ZIMBRA") - 1 + 2;
+                line.data = ngx_palloc (c->pool, line.len);
+
+                if (line.data == NULL) {
+                    ngx_mail_proxy_internal_server_error(s);
+                    return;
+                }
+
+                ngx_snprintf (line.data, line.len, "%V AUTHENTICATE X-ZIMBRA" CRLF, &s->tag);
+            }
+            else
+            {
+                s->connection->log->action = "sending AUTHENTICATE PLAIN to upstream";
+
+                line.len = s->tag.len + 1 /* for space */ + sizeof ("AUTHENTICATE PLAIN") - 1 + 2;
+                line.data = ngx_palloc (c->pool, line.len);
+
+                if (line.data == NULL) {
+                    ngx_mail_proxy_internal_server_error(s);
+                    return;
+                }
+
+                ngx_snprintf (line.data, line.len, "%V AUTHENTICATE PLAIN" CRLF, &s->tag);
+            }
+
+            s->mail_state = ngx_imap_auth_plain;
+        }
         break;
 
     case ngx_imap_login:
@@ -387,15 +920,15 @@
 
         s->connection->log->action = "sending user name to upstream";
 
-        line.len = s->login.len + 1 + 1 + NGX_SIZE_T_LEN + 1 + 2;
+        line.len = s->qlogin.len + 1 + 1 + NGX_SIZE_T_LEN + 1 + 2;
         line.data = ngx_pnalloc(c->pool, line.len);
         if (line.data == NULL) {
             ngx_mail_proxy_internal_server_error(s);
             return;
         }
 
-        line.len = ngx_sprintf(line.data, "%V {%uz}" CRLF,
-                               &s->login, s->passwd.len)
+        line.len = ngx_sprintf(line.data, "%V%V {%uz}" CRLF,
+                               &s->qlogin, &s->zlogin, s->passwd.len)
                    - line.data;
 
         s->mail_state = ngx_imap_user;
@@ -421,25 +954,67 @@
         break;
 
     case ngx_imap_passwd:
-        s->connection->read->handler = ngx_mail_proxy_handler;
-        s->connection->write->handler = ngx_mail_proxy_handler;
-        rev->handler = ngx_mail_proxy_handler;
-        c->write->handler = ngx_mail_proxy_handler;
+    case ngx_imap_auth_plain_ir:
+        ngx_mail_proxy_throttle_imap(rev);
+        return;
 
-        pcf = ngx_mail_get_module_srv_conf(s, ngx_mail_proxy_module);
-        ngx_add_timer(s->connection->read, pcf->timeout);
-        ngx_del_timer(c->read);
+    case ngx_imap_auth_plain:
+        /* RFC 4616
+           message   = [authzid] UTF8NUL authcid UTF8NUL passwd 
+         */
 
-        c->log->action = NULL;
-        ngx_log_error(NGX_LOG_INFO, c->log, 0, "client logged in");
+        challenge.len = s->qlogin.len + s->zlogin.len + 1 +
+                        s->dusr.len + s->zusr.len + 1 +
+                        s->dpasswd.len;
+        line.len = ngx_base64_encoded_length (challenge.len);
 
-        ngx_mail_proxy_handler(s->connection->write);
+        challenge.data = ngx_palloc (c->pool, challenge.len);
+        if (challenge.data == NULL) {
+            ngx_mail_proxy_internal_server_error(s);
+            return;
+        }
 
-        return;
+        line.data = ngx_palloc (c->pool, line.len + 2);   /* +2 for CRLF */
+        if (line.data == NULL) {
+            ngx_mail_proxy_internal_server_error(s);
+            return;
+        }
+
+        /* construct the base64 challenge for auth-plain login to upstream */
+
+        p = challenge.data;
+        p = ngx_cpymem(p, s->qlogin.data, s->qlogin.len);   /* authz */
+        p = ngx_cpymem(p, s->zlogin.data, s->zlogin.len); /* [/wm|/ni|/tb] */
+        *p++ = '\x0';
+        p = ngx_cpymem(p, s->dusr.data, s->dusr.len);     /* authc */
+        p = ngx_cpymem(p, s->zusr.data, s->zusr.len);     /* [/wm|/ni|/tb] for authc */
+        *p++ = '\x0';
+        p = ngx_cpymem(p, s->dpasswd.data, s->dpasswd.len); /* password */
+
+        ngx_encode_base64 (&line, &challenge);
+
+        if (s->auth_method == NGX_MAIL_AUTH_GSSAPI) {
+            ngx_log_debug0 (NGX_LOG_DEBUG_MAIL, rev->log, 0,
+                            "sending AUTH X-ZIMBRA challenge to upstream"
+                           );
+        }
+        else {
+            ngx_log_debug0 (NGX_LOG_DEBUG_MAIL, rev->log, 0,
+                            "sending AUTH PLAIN challenge to upstream"
+                           );
+        }
+
+        ngx_memcpy (line.data + line.len, CRLF, 2);
+        line.len += 2;
+
+        s->mail_state = ngx_imap_auth_plain_ir;
+
+        break;
 
     default:
 #if (NGX_SUPPRESS_WARN)
-        ngx_str_null(&line);
+        line.len = 0;
+        line.data = NULL;
 #endif
         break;
     }
@@ -603,10 +1178,10 @@
             return;
         }
 
-        line.len = ngx_sprintf(line.data,
+            line.len = ngx_sprintf(line.data,
                        ((s->esmtp) ? "EHLO %V" CRLF : "HELO %V" CRLF),
                        &s->smtp_helo)
-                   - line.data;
+                       - line.data;
 
         s->mail_state = (s->auth_method == NGX_MAIL_AUTH_NONE) ?
                             ngx_smtp_helo_from : ngx_smtp_helo;
@@ -734,6 +1309,33 @@
     ssize_t                 n;
     ngx_buf_t              *b;
     ngx_mail_proxy_conf_t  *pcf;
+    int                     expect_chunk;
+
+    /* (bug 21323)
+
+       during the authentication phase, the upstream imap server can include an
+       optional untagged response to the LOGIN or to the ID command
+       if the `nio_imap_enabled' parameter is set to true, then the upstream 
+       server's response is split into two tcp packets, the first chunk
+       contains the untagged response, and the next chunk contains the tagged
+       result
+
+       in this function, nginx previously expected all the response to arrive
+       in a single chunk, which is not true in this case, and therefore, we 
+       must maintain a state variable (expect_chunk), which has boolean 
+       significance -- if the variable starts off as false, and it is marked 
+       true when we encounter an untagged response
+
+       when the tagged response eventually arrives (the tag identifier is at 
+       the start of a new line of response), then this variable is signaled
+       to false again, which means that we don't expect another chunk of 
+       data
+
+       if we finish processing the data returned by the call to recv(), and
+       if expect_chunk is set to true, then we return NGX_AGAIN, which will
+       cause this handler to get invoked again, when the next chunk of data
+       becomes available
+     */
 
     s->connection->log->action = "reading response from upstream";
 
@@ -752,7 +1354,12 @@
 
     b->last += n;
 
-    if (b->last - b->pos < 4) {
+    /* if (b->last - b->pos < 5) {
+        return NGX_AGAIN;
+    } */ /* -- This won't work with zimbra */
+
+    if ((b->last - b->pos < 5) && (b->pos) && (*b->pos != '+'))
+    {
         return NGX_AGAIN;
     }
 
@@ -768,13 +1375,20 @@
         return NGX_AGAIN;
     }
 
+    expect_chunk = 0;
     p = b->pos;
 
     switch (s->protocol) {
 
     case NGX_MAIL_POP3_PROTOCOL:
-        if (p[0] == '+' && p[1] == 'O' && p[2] == 'K') {
-            return NGX_OK;
+        if (state == ngx_pop3_auth_plain) {
+            if (p[0] == '+' && p[1] == ' ') {
+                return NGX_OK;
+            }
+        } else {
+            if (p[0] == '+' && p[1] == 'O' && p[2] == 'K') {
+                return NGX_OK;
+            }
         }
         break;
 
@@ -789,18 +1403,78 @@
 
         case ngx_imap_login:
         case ngx_imap_user:
+        case ngx_imap_auth_plain:
             if (p[0] == '+') {
                 return NGX_OK;
             }
             break;
 
-        case ngx_imap_passwd:
-            if (ngx_strncmp(p, s->tag.data, s->tag.len) == 0) {
-                p += s->tag.len;
-                if (p[0] == 'O' && p[1] == 'K') {
+        case ngx_imap_id:
+            if (*p == '*') {
+                /* bug 60751 identify the [ALERT] msg from upstream */
+                if (ngx_strncmp(p, "* OK [ALERT]", sizeof("* OK [ALERT]") - 1) == 0) {
+                    s->out.len = b->last - b->pos;
+                    s->out.data = b->pos;
+                    return NGX_ABORT;
+                }
+
+                /* bug 68678 ignore the untagged error for the ID command */
+                if (ngx_strncmp(p, "* BAD", sizeof("* BAD") - 1) == 0) {
                     return NGX_OK;
                 }
             }
+            /* fall through */
+        case ngx_imap_passwd:
+        case ngx_imap_auth_plain_ir:
+            /* Consume (optional, untagged response, plus) tagged response to 
+               IMAP command previously issued
+               As the switch case indicates, we are prepared to handle this 
+               after sending the ID command, or after sending the password to
+               the upstream imap server
+               In the former case, the IMAP server MAY optionally include an
+               untagged ID repsonse (RFC 2971, section 3.1)
+               In the latter case, the IMAP server MAY include a CAPABILITY
+               response code in the tagged OK response to a successful LOGIN
+               command (RFC 3501, section 6.2.3)
+             */
+
+            while ((p != NULL) && (p < b->last))
+            {
+                if (ngx_strncmp(p, s->tag.data, s->tag.len) == 0)
+                {
+                    /* This line is the tagged response */
+                    expect_chunk = 0;
+
+                    p += s->tag.len + 1 /*for space*/;
+                    if (p[0] == 'O' && p[1] == 'K')
+                    {
+                        return NGX_OK;
+                    }
+                    else
+                    {
+                        break;
+                    }
+                }
+                else
+                {
+                    /* this line is any optional untagged response 
+                     */
+                    p = (u_char *)strstr ((char *)p, (char *)"\n");
+                    if (!p)
+                    {
+                        /* if we don't find the newline, it indicates an
+                           invalid response
+                         */
+                        break;
+                    }
+                    else
+                    {
+                        /* the first (possible) chunk has been read */
+                        expect_chunk = 1;
+                        ++p;
+                    }
+                }
+            }
             break;
         }
 
@@ -858,6 +1532,11 @@
         break;
     }
 
+    if (expect_chunk == 1) {
+        return NGX_AGAIN;
+    }
+
+    s->sendquitmsg = 1;
     pcf = ngx_mail_get_module_srv_conf(s, ngx_mail_proxy_module);
 
     if (pcf->pass_error_message == 0) {
@@ -908,6 +1587,7 @@
                           "upstream timed out");
         }
 
+        s->sendquitmsg = 1;
         ngx_mail_proxy_close_session(s);
         return;
     }
@@ -985,7 +1665,14 @@
 
             n = src->recv(src, b->last, size);
 
-            if (n == NGX_AGAIN || n == 0) {
+            if (n == NGX_AGAIN) {
+                break;
+            }
+
+            if (n == 0) {
+                if (c == s->connection && !ev->write) {
+                    s->sendquitmsg = 1;
+                }
                 break;
             }
 
@@ -1047,7 +1734,10 @@
     }
 }
 
-
+/* error out of an established proxy session
+    - close the upstream connection
+    - close the downstream connection after sending any pending data
+ */
 static void
 ngx_mail_proxy_upstream_error(ngx_mail_session_t *s)
 {
@@ -1063,7 +1753,7 @@
         ngx_mail_session_internal_server_error(s);
         return;
     }
-
+    
     s->quit = 1;
     ngx_mail_send(s->connection->write);
 }
@@ -1091,11 +1781,22 @@
         ngx_log_debug1(NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
                        "close mail proxy connection: %d",
                        s->proxy->upstream.connection->fd);
+#if (NGX_MAIL_SSL)
+
+        if (s->proxy->upstream.connection->ssl) {
+            s->proxy->upstream.connection->ssl->no_wait_shutdown = 1;
+            ngx_ssl_shutdown(s->proxy->upstream.connection);
+        }
+#endif
 
         ngx_close_connection(s->proxy->upstream.connection);
     }
 
-    ngx_mail_close_connection(s->connection);
+    if (s->sendquitmsg) {
+        ngx_mail_end_session(s);
+    } else {
+        ngx_mail_close_connection(s->connection);
+    }
 }
 
 
@@ -1111,9 +1812,16 @@
 
     pcf->enable = NGX_CONF_UNSET;
     pcf->pass_error_message = NGX_CONF_UNSET;
+    pcf->issue_pop3_xoip = NGX_CONF_UNSET;
+    pcf->issue_imap_id = NGX_CONF_UNSET;
+    pcf->xclient = NGX_CONF_UNSET;
     pcf->xclient = NGX_CONF_UNSET;
     pcf->buffer_size = NGX_CONF_UNSET_SIZE;
+    pcf->ctimeout = NGX_CONF_UNSET_MSEC;
     pcf->timeout = NGX_CONF_UNSET_MSEC;
+    pcf->proxy_ssl = NGX_CONF_UNSET;
+    pcf->proxy_ssl_session_reuse = NGX_CONF_UNSET;
+    pcf->ssl = NGX_CONF_UNSET_PTR;
 
     return pcf;
 }
@@ -1127,10 +1835,507 @@
 
     ngx_conf_merge_value(conf->enable, prev->enable, 0);
     ngx_conf_merge_value(conf->pass_error_message, prev->pass_error_message, 0);
+    ngx_conf_merge_value(conf->issue_pop3_xoip, prev->issue_pop3_xoip, 1);
+    ngx_conf_merge_value(conf->issue_imap_id, prev->issue_imap_id, 1);
     ngx_conf_merge_value(conf->xclient, prev->xclient, 1);
+    ngx_conf_merge_value(conf->proxy_ssl, prev->proxy_ssl, 0);
+    ngx_conf_merge_value(conf->proxy_ssl_session_reuse, prev->proxy_ssl_session_reuse, 1);
+    ngx_conf_merge_ptr_value(conf->ssl, prev->ssl, NULL);
     ngx_conf_merge_size_value(conf->buffer_size, prev->buffer_size,
                               (size_t) ngx_pagesize);
+    ngx_conf_merge_msec_value(conf->ctimeout, prev->ctimeout, 2 * 60000);
     ngx_conf_merge_msec_value(conf->timeout, prev->timeout, 24 * 60 * 60000);
 
     return NGX_CONF_OK;
 }
+
+#if (NGX_MAIL_SSL)
+
+static char *
+ngx_mail_proxy_ssl(ngx_conf_t *cf, ngx_command_t *cmd, void *conf) {
+
+    ngx_pool_cleanup_t    *cln;
+    char                  *rc;
+    ngx_mail_proxy_conf_t *pcf;
+
+    rc = ngx_conf_set_flag_slot(cf, cmd, conf);
+    if (rc != NGX_CONF_OK) {
+        return rc;
+    }
+
+    pcf = (ngx_mail_proxy_conf_t *)conf;
+
+    if (!pcf->proxy_ssl) {
+        return NGX_CONF_OK;
+    }
+
+    pcf->ssl = ngx_pcalloc(cf->pool, sizeof(ngx_ssl_t));
+
+    if (pcf->ssl == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    pcf->ssl->log = cf->log;
+
+    // don't support SSLv2 anymore
+    if (ngx_ssl_create(pcf->ssl, NGX_SSL_SSLv3|NGX_SSL_TLSv1, NULL)
+            != NGX_OK) {
+        return NGX_CONF_ERROR;
+    }
+
+    cln = ngx_pool_cleanup_add(cf->pool, 0);
+    if (cln == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    cln->handler = ngx_ssl_cleanup_ctx;
+    cln->data = pcf->ssl;
+
+    return NGX_CONF_OK;
+}
+
+#endif
+/* throttle imap session if necessary (user has just finished logging in) */
+static void ngx_mail_proxy_throttle_imap(ngx_event_t *rev)
+{
+    throttle_callback_t          *callback;
+    ngx_mail_throttle_srv_conf_t *tscf;
+    ngx_mail_proxy_conf_t        *pcf;
+    ngx_mail_session_t           *s;
+    ngx_connection_t             *c;
+    ngx_pool_t                   *pool;
+    ngx_log_t                    *log;
+    ngx_str_t                     user;
+
+    c = rev->data;
+    s = c->data;
+    pool = c->pool;
+    log = ngx_cycle->log;
+    tscf = ngx_mail_get_module_srv_conf(s, ngx_mail_throttle_module);
+    pcf = ngx_mail_get_module_srv_conf(s, ngx_mail_proxy_module);
+
+    callback = ngx_pcalloc(pool, sizeof(throttle_callback_t));
+    if (callback == NULL) {
+        ngx_mail_proxy_upstream_error(s);
+        return;
+    }
+
+    callback->check_only = 0;    /* increment the counter */
+    callback->session = s;
+    callback->connection = c;
+    callback->rev = rev;
+    callback->config = pcf;
+    callback->log = log;
+    callback->pool = pool;
+    callback->on_allow = ngx_mail_proxy_allow_imap;
+    callback->on_deny = ngx_mail_proxy_choke_imap;
+
+    if (tscf->mail_login_user_max == 0) {
+        callback->on_allow(callback);
+    } else {
+        user = s->qlogin;
+        if ((user.len == 0) && (s->auth_method == NGX_MAIL_AUTH_PLAIN
+                || s->auth_method == NGX_MAIL_AUTH_PLAIN_IR)) {
+            user = s->dusr;
+        }
+        ngx_mail_throttle_user(user, callback);
+    }
+}
+
+static void ngx_mail_proxy_allow_imap(throttle_callback_t *callback)
+{
+    ngx_mail_session_t      *s = callback->session;
+    ngx_event_t             *rev = callback->rev;
+    ngx_connection_t        *c = callback->connection;
+    ngx_mail_proxy_conf_t   *pcf = callback->config;
+
+    s->connection->read->handler = ngx_mail_proxy_handler;
+    s->connection->write->handler = ngx_mail_proxy_handler;
+    rev->handler = ngx_mail_proxy_handler;
+    c->write->handler = ngx_mail_proxy_handler;
+
+    ngx_add_timer(s->connection->read, pcf->timeout);
+    if (c->read->timer_set) {
+        ngx_del_timer(c->read);
+    }
+
+    c->log->action = NULL;
+    ngx_log_error(NGX_LOG_INFO, c->log, 0, "client logged in");
+
+    ngx_mail_proxy_handler(s->connection->write);
+}
+
+static void ngx_mail_proxy_choke_imap(throttle_callback_t *callback)
+{
+    ngx_mail_session_t  *s = callback->session;
+    ngx_mail_proxy_choke_session(s);
+}
+
+/* throttle pop3 session if necessary (user has just finished logging in) */
+static void ngx_mail_proxy_throttle_pop3(ngx_event_t *rev)
+{
+    throttle_callback_t          *callback;
+    ngx_mail_throttle_srv_conf_t *tscf;
+    ngx_mail_proxy_conf_t        *pcf;
+    ngx_mail_session_t           *s;
+    ngx_connection_t             *c;
+    ngx_pool_t                   *pool;
+    ngx_log_t                    *log;
+    ngx_str_t                     user;
+
+    c = rev->data;
+    s = c->data;
+    pool = c->pool;
+    log = ngx_cycle->log;
+    tscf = ngx_mail_get_module_srv_conf(s, ngx_mail_throttle_module);
+    pcf = ngx_mail_get_module_srv_conf(s, ngx_mail_proxy_module);
+
+    callback = ngx_pcalloc(pool, sizeof(throttle_callback_t));
+    if (callback == NULL) {
+        ngx_mail_proxy_upstream_error(s);
+        return;
+    }
+
+    callback->check_only = 0;    /* increment the counter */
+    callback->session = s;
+    callback->connection = c;
+    callback->rev = rev;
+    callback->config = pcf;
+    callback->log = log;
+    callback->pool = pool;
+    callback->on_allow = ngx_mail_proxy_allow_pop3;
+    callback->on_deny = ngx_mail_proxy_choke_pop3;
+
+    if (tscf->mail_login_user_max == 0) {
+        callback->on_allow(callback);
+    } else {
+        user = s->qlogin;
+        if ((user.len == 0) && (s->auth_method == NGX_MAIL_AUTH_PLAIN
+                || s->auth_method == NGX_MAIL_AUTH_PLAIN_IR)) {
+            user = s->dusr;
+        }
+        ngx_mail_throttle_user(user, callback);
+    }
+}
+
+static void ngx_mail_proxy_allow_pop3(throttle_callback_t *callback)
+{
+    ngx_mail_session_t      *s = callback->session;
+    ngx_event_t             *rev = callback->rev;
+    ngx_connection_t        *c = callback->connection;
+    ngx_mail_proxy_conf_t   *pcf = callback->config;
+
+    s->connection->read->handler = ngx_mail_proxy_handler;
+    s->connection->write->handler = ngx_mail_proxy_handler;
+    rev->handler = ngx_mail_proxy_handler;
+    c->write->handler = ngx_mail_proxy_handler;
+
+    ngx_add_timer(s->connection->read, pcf->timeout);
+    if (c->read->timer_set) {
+        ngx_del_timer(c->read);
+    }
+
+    c->log->action = NULL;
+    ngx_log_error(NGX_LOG_INFO, c->log, 0, "client logged in");
+
+    ngx_mail_proxy_handler(s->connection->write);
+}
+
+static void ngx_mail_proxy_choke_pop3(throttle_callback_t *callback)
+{
+    ngx_mail_session_t  *s = callback->session;
+    ngx_mail_proxy_choke_session(s);
+}
+
+static void ngx_mail_proxy_choke_session(ngx_mail_session_t *s)
+{
+    ngx_mail_throttle_srv_conf_t *tscf;
+    ngx_str_t                     bye, msg, umsg;
+    ngx_pool_t                   *pool;
+    u_char                       *p;
+
+    tscf = ngx_mail_get_module_srv_conf(s, ngx_mail_throttle_module);
+    pool = s->connection->pool;
+    msg = tscf->mail_login_user_rejectmsg;
+
+    if (s->proxy->upstream.connection)
+    {
+        ngx_log_debug1(NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+                       "close mail proxy connection: %d",
+                       s->proxy->upstream.connection->fd);
+
+        ngx_close_connection(s->proxy->upstream.connection);
+    }
+
+    if (s->protocol == NGX_MAIL_IMAP_PROTOCOL)
+    {
+        bye.len =   sizeof("* BYE ") - 1 +
+                    msg.len +
+                    sizeof(CRLF) - 1;
+
+        bye.data = ngx_palloc(pool, bye.len);
+
+        if (bye.data != NULL)
+        {
+            p = bye.data;
+            p = ngx_cpymem(p,"* BYE ",sizeof("* BYE ")-1);
+            p = ngx_cpymem(p, msg.data, msg.len);
+            *p++ = CR;
+            *p++ = LF;
+            bye.len = p - bye.data;
+        }
+        else
+        {
+            bye.data = (u_char *) ("* BYE" CRLF);
+            bye.len = sizeof("* BYE" CRLF)-1;
+        }
+
+        s->out = bye;
+        s->quit = 0;
+        ngx_mail_send(s->connection->write);
+
+        if (s->command == NGX_IMAP_LOGIN) {
+            umsg.data = imap_login_no;
+            umsg.len = sizeof(imap_login_no) - 1;
+        } else if (s->command == NGX_IMAP_AUTHENTICATE) {
+            umsg.data = imap_auth_no;
+            umsg.len = sizeof(imap_auth_no) - 1;
+        } else {
+            umsg.data = imap_no;
+            umsg.len = sizeof(imap_no) - 1;
+        }
+
+        s->out.len = s->tag.len + 1 /*for space*/+ umsg.len;
+        s->out.data = ngx_palloc(pool, s->out.len);
+
+        if (s->out.data == NULL) {
+            s->out.data = (u_char*)"";
+            s->out.len = 0;
+            ngx_mail_close_connection(s->connection);
+        } else {
+            ngx_memcpy(s->out.data, s->tag.data, s->tag.len);
+            *(s->out.data + s->tag.len) = ' ';
+            ngx_memcpy(s->out.data + s->tag.len + 1, umsg.data, umsg.len);
+            s->quit = 1;
+            ngx_mail_send(s->connection->write);
+        }
+
+        return;
+    }
+    else if (s->protocol == NGX_MAIL_POP3_PROTOCOL)
+    {
+        bye.len = sizeof("-ERR ")-1 +
+                  msg.len +
+                  sizeof(CRLF)-1;
+
+        bye.data = ngx_palloc(pool,bye.len);
+
+        if (bye.data != NULL)
+        {
+            p = bye.data;
+            p = ngx_cpymem(p,"-ERR ",sizeof("-ERR ")-1);
+            p = ngx_cpymem(p,msg.data,msg.len);
+            *p++ = CR;
+            *p++ = LF;
+            bye.len = p-bye.data;
+        }
+        else
+        {
+            bye.data = (u_char *)("-ERR" CRLF);
+            bye.len = sizeof("-ERR" CRLF)-1;
+        }
+
+        s->out = bye;
+        s->quit = 1;
+        ngx_mail_send(s->connection->write);
+        return;
+    }
+    else
+    {
+        /* TODO ?? reject SMTP ?? */
+        bye.data = (u_char *)"";
+        bye.len = 0;
+        s->out = bye;
+        s->quit = 1;
+        ngx_mail_send(s->connection->write);
+        return;
+    }
+}
+
+/* Quote an IMAP string according to RFC 3501, section 9 (formal syntax) */
+static ngx_str_t ngx_imap_quote_string(ngx_pool_t *pool, ngx_str_t *u)
+{
+    size_t      s;
+    ngx_str_t   k;
+    u_char     *p,*q,*r;
+
+    s = 2;
+    q = u->data;
+    r = q + u->len;
+
+    while (q<r) {
+        if (*q == '"' || *q == '\\') { ++s; }
+        ++s;
+        ++q;
+    }
+
+    k.data = ngx_palloc(pool,s);
+    if (k.data == NULL) {
+        k = *u;
+    } else {
+        k.len = s;
+        p = k.data;
+        q = u->data;
+        r = q + u->len;
+        *p++ = '"';
+        while (q<r) {
+            if (*q == '"' || *q == '\\') { *p++ = '\\'; }
+            *p++ = *q++;
+        }
+        *p++ = '"';
+    }
+
+    return k;
+}
+
+static void
+ngx_mail_proxy_auth_sleep_handler (ngx_event_t *rev)
+{
+    ngx_connection_t        *c;
+    ngx_mail_session_t      *s;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0,
+        "mail proxy auth sleep handler");
+
+    c = rev->data;
+    s = c->data;
+
+    ngx_zm_lookup_delete_cache(s->key_alias, s->key_route);
+
+    if (rev->timedout) {
+        ngx_mail_proxy_upstream_error(s);
+        return;
+    }
+
+    if (rev->active) {
+        if (ngx_handle_read_event(rev, 0) == NGX_ERROR) {
+            ngx_mail_proxy_upstream_error(s);
+        }
+    }
+}
+
+ngx_flag_t
+ngx_mail_get_proxy_ssl (ngx_mail_session_t * s)
+{
+    ngx_mail_proxy_conf_t * pcf = ngx_mail_get_module_srv_conf(s, ngx_mail_proxy_module);
+    return pcf->proxy_ssl;
+}
+
+#if (NGX_HTTP_SSL)
+
+static void
+ngx_mail_proxy_ssl_init_connection(ngx_mail_session_t *s, ngx_connection_t *c)
+{
+    ngx_int_t               rc;
+    ngx_mail_proxy_conf_t  *pcf;
+
+    pcf = ngx_mail_get_module_srv_conf(s, ngx_mail_proxy_module);
+
+    if (ngx_ssl_create_connection(pcf->ssl, c,
+                                  NGX_SSL_BUFFER|NGX_SSL_CLIENT)
+        != NGX_OK)
+    {
+        ngx_mail_proxy_internal_server_error(s);
+        return;
+    }
+
+    /**
+     * TODO support session reuse
+    if (pcf->ssl_session_reuse) {
+        if (u->peer.set_session(&u->peer, u->peer.data) != NGX_OK) {
+            ngx_mail_internal_server_error(s);
+            return;
+        }
+    }
+    */
+
+    s->connection->log->action = "SSL handshaking to upstream";
+
+    rc = ngx_ssl_handshake(c);
+
+    if (rc == NGX_AGAIN) {
+        c->ssl->handler = ngx_mail_proxy_ssl_handshake;
+        return;
+    }
+
+    ngx_mail_proxy_ssl_handshake(c);
+}
+
+
+static void
+ngx_mail_proxy_ssl_handshake(ngx_connection_t *c)
+{
+    ngx_mail_session_t  *s;
+    s = c->data;
+
+    if (c->ssl->handshaked) {
+
+        /**
+         * TODO support ssl session reuse
+
+        if (pcf->ssl_session_reuse) {
+            ngx_mail_proxy_save_session(s, c);
+        }
+        */
+        c->write->handler = ngx_mail_proxy_dummy_handler;
+        switch (s->protocol) {
+
+            case NGX_MAIL_POP3_PROTOCOL:
+                c->read->handler = ngx_mail_proxy_pop3_handler;
+                s->mail_state = ngx_pop3_start;
+                break;
+
+            case NGX_MAIL_IMAP_PROTOCOL:
+                c->read->handler = ngx_mail_proxy_imap_handler;
+                s->mail_state = ngx_imap_start;
+                break;
+
+            default: /* NGX_MAIL_SMTP_PROTOCOL */
+                c->read->handler = ngx_mail_proxy_smtp_handler;
+                s->mail_state = ngx_smtp_start;
+                break;
+        }
+
+        /* server might have send the intial welcome msg */
+        c->read->handler(c->read);
+    } else {
+        /* when handshake fails, we should close the session */
+        ngx_mail_proxy_upstream_error(s);
+    }
+}
+
+/** TODO support ssl session reuse
+void
+ngx_mail_proxy_set_session (ngx_peer_connection_t *pc, ngx_mail_proxy_ctx_t *ctx)
+{
+    ngx_ssl_session_t   *ssl_session;
+    ngx_int_t            rc;
+
+    ssl_session = peer->ssl_session;
+
+    rc = ngx_ssl_set_session(pc->connection, ssl_session);
+
+    ngx_log_debug2(NGX_LOG_DEBUG_MAIL, pc->log, 0,
+                   "set session: %p:%d",
+                   ssl_session, ssl_session ? ssl_session->references : 0);
+    return;
+}
+
+void
+ngx_mail_proxy_save_session (ngx_peer_connection_t *pc)
+{
+
+}
+*/
+
+#endif
diff -ur nginx-1.7.1/src/mail/ngx_mail_smtp_module.c nginx-1.7.1-zimbra/src/mail/ngx_mail_smtp_module.c
--- nginx-1.7.1/src/mail/ngx_mail_smtp_module.c	2014-05-27 06:58:10.000000000 -0700
+++ nginx-1.7.1-zimbra/src/mail/ngx_mail_smtp_module.c	2014-07-23 12:24:10.000000000 -0700
@@ -45,7 +45,8 @@
     ngx_mail_smtp_parse_command,
     ngx_mail_smtp_auth_state,
 
-    ngx_string("451 4.3.2 Internal server error" CRLF)
+    ngx_string("451 4.3.2 Internal server error" CRLF),
+    ngx_string("") /* zimbra add a quite_msg field in mail protocol */
 };
 
 
Only in nginx-1.7.1-zimbra/src/mail: ngx_mail_throttle_module.c
Only in nginx-1.7.1-zimbra/src/mail: ngx_mail_throttle_module.h
Only in nginx-1.7.1-zimbra/src/mail: ngx_mail_zmauth_module.c
Only in nginx-1.7.1-zimbra/src/mail: ngx_mail_zmauth_module.h
diff -ur nginx-1.7.1/src/os/unix/ngx_process_cycle.c nginx-1.7.1-zimbra/src/os/unix/ngx_process_cycle.c
--- nginx-1.7.1/src/os/unix/ngx_process_cycle.c	2014-05-27 06:58:10.000000000 -0700
+++ nginx-1.7.1-zimbra/src/os/unix/ngx_process_cycle.c	2014-08-04 14:29:36.000000000 -0700
@@ -93,6 +93,7 @@
     ngx_msec_t         delay;
     ngx_listening_t   *ls;
     ngx_core_conf_t   *ccf;
+    struct rlimit     rlmt;
 
     sigemptyset(&set);
     sigaddset(&set, SIGCHLD);
@@ -135,6 +136,66 @@
 
     ngx_start_worker_processes(cycle, ccf->worker_processes,
                                NGX_PROCESS_RESPAWN);
+    /* The directives such as "user", "rlimit_core", etc. should also be
+     * effective on master process. Changed by Zimbra
+     */
+    if (ccf->rlimit_nofile != NGX_CONF_UNSET) {
+    	rlmt.rlim_cur = (rlim_t) ccf->rlimit_nofile;
+    	rlmt.rlim_max = (rlim_t) ccf->rlimit_nofile;
+
+    	if (setrlimit(RLIMIT_NOFILE, &rlmt) == -1) {
+    		ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
+    				"setrlimit(RLIMIT_NOFILE, %i) failed",
+    				ccf->rlimit_nofile);
+        }
+    }
+
+    if (ccf->rlimit_core != NGX_CONF_UNSET) {
+    	rlmt.rlim_cur = (rlim_t) ccf->rlimit_core;
+    	rlmt.rlim_max = (rlim_t) ccf->rlimit_core;
+
+    	if (setrlimit(RLIMIT_CORE, &rlmt) == -1) {
+    		ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
+    				"setrlimit(RLIMIT_CORE, %O) failed",
+    				ccf->rlimit_core);
+        }
+    }
+
+#ifdef RLIMIT_SIGPENDING
+    if (ccf->rlimit_sigpending != NGX_CONF_UNSET) {
+    	rlmt.rlim_cur = (rlim_t) ccf->rlimit_sigpending;
+    	rlmt.rlim_max = (rlim_t) ccf->rlimit_sigpending;
+
+    	if (setrlimit(RLIMIT_SIGPENDING, &rlmt) == -1) {
+    		ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
+    				"setrlimit(RLIMIT_SIGPENDING, %i) failed",
+    				ccf->rlimit_sigpending);
+        }
+    }
+#endif
+
+    if (geteuid() == 0) {
+    	if (setgid(ccf->group) == -1) {
+    		ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,
+    				"setgid(%d) failed", ccf->group);
+            /* fatal */
+    		exit(2);
+    	}
+
+        if (initgroups(ccf->username, ccf->group) == -1) {
+        	ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,
+        			"initgroups(%s, %d) failed",
+        			ccf->username, ccf->group);
+        }
+
+        if (setuid(ccf->user) == -1) {
+        	ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,
+        			"setuid(%d) failed", ccf->user);
+        	/* fatal */
+        	exit(2);
+        }
+    }
+    /* end change by Zimbra */
     ngx_start_cache_manager_processes(cycle, 0);
 
     ngx_new_binary = 0;
